/*
 * Copyright (C) 2016 MediaTek Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
 * generated by sensor driver assistant
 */

/*****************************************************************************
 *
 * Filename:
 * ---------
 *     ovA0B40qmipiraw_Sensor.c
 *
 * Project:
 * --------
 *     ALPS
 *
 * Description:
 * ------------
 *     Source code of Sensor driver
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#define PFX "ovA0B40q_mipi_raw"
#define pr_fmt(fmt) PFX "[%s] " fmt, __func__


#include <linux/videodev2.h>
#include <linux/i2c.h>
#include <linux/platform_device.h>
#include <linux/delay.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/fs.h>
#include <linux/atomic.h>
#include <linux/types.h>

#include "kd_camera_typedef.h"
#include "kd_imgsensor.h"
#include "kd_imgsensor_define.h"
#include "kd_imgsensor_errcode.h"

#include "ova0b4mipiraw_changzheng_Sensor.h"
#include "ova0b4mipiraw_changzheng_Setting.h"
#include "ova0b4_seamless_switch.h"

static DEFINE_SPINLOCK(imgsensor_drv_lock);
extern void register_imgsensor_deviceinfo(char *name, char *version, u8 module_id);
#define DEVICE_VERSION_CHANGZHENG_OVA0B40Q    "ova0b4"
static kal_uint8 deviceInfo_register_value = 0x00;
static kal_uint32 last_shutter = 0;
#define EEPROM_I2C_ADDR 0xA0

static struct imgsensor_info_struct imgsensor_info = {
    .sensor_id = OVA0B4_SENSOR_ID_CHANGZHENG,
    .checksum_value = 0x2442829D,
    .preview = {
        .pclk = 100000000,
        .linelength =  750,
        .framelength = 4444,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 4000,
        .grabwindow_height = 3000,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 1017600000,
        .max_framerate = 300,
    },

    .capture = {
        .pclk = 100000000,
        .linelength =   700,
        .framelength = 4760,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 4000,
        .grabwindow_height = 3000,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 1017600000,
        .max_framerate = 300,
    },

    .normal_video = {
        .pclk = 100000000,
        .linelength =   750,
        .framelength = 4444,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 4000,
        .grabwindow_height = 2256,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 1017600000,
        .max_framerate = 300,
    },

    .high_speed_video = {
        .pclk = 100000000,
        .linelength =   532,
        .framelength = 1564,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 2688,
        .grabwindow_height = 1512,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 1017600000,
        .max_framerate = 1200,
    },

    .slim_video = {
        .pclk = 1600000000,
        .linelength =   8352,
        .framelength = 6348,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 2880,
        .grabwindow_height = 1620,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 1017600000,
        .max_framerate = 300,
    },

    .custom1 = {
        .pclk = 1600000000,
        .linelength =   12000,
        .framelength = 5554,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 4000,
        .grabwindow_height = 3000,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 1017600000,
        .max_framerate = 240,
    },

    .custom2 = {
        .pclk = 100000000,
        .linelength =   850,
        .framelength = 4900,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 5792,
        .grabwindow_height = 4344,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 1017600000,
        .max_framerate = 240,
    },

    .custom3 = {
        .pclk = 100000000,
        .linelength =  2850,
        .framelength = 4676,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 11584,
        .grabwindow_height =  8688,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 1017600000,
        .max_framerate = 75,
    },

    .custom4 = {
        .pclk = 1600000000,
        .linelength =   8400,
        .framelength = 6348,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 2880,
        .grabwindow_height = 1620,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 1017600000,
        .max_framerate = 300,
    },

    .custom5 = {
        .pclk = 100000000,
        .linelength =   775,
        .framelength = 4300,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 4000,
        .grabwindow_height = 3000,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 1017600000,
        .max_framerate = 300,
    },
    .custom6 = {
        .pclk = 100000000,
        .linelength =   522,
        .framelength = 7980,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 2880,
        .grabwindow_height = 1620,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 1017600000,
        .max_framerate = 240, //different from slim video,slim video pclk&linelength X16,so need to add custom6
    },

    .margin = 17,
    .min_shutter = 8,
    .min_gain = 64,
    .max_gain = 3968,
    .min_gain_iso = 100,
    .exp_step = 1,
    .gain_step = 1,
    .gain_type = 1,
    .max_frame_length = 0xFFFFFF,
    .ae_shut_delay_frame = 0,
    .ae_sensor_gain_delay_frame = 0,
    .ae_ispGain_delay_frame = 2,    /* isp gain delay frame for AE cycle */
    .ihdr_support = 0,    /* 1, support; 0,not support */
    .ihdr_le_firstline = 0,    /* 1,le first ; 0, se first */
    .temperature_support = 1,/* 1, support; 0,not support */
    .sensor_mode_num = 11,//support sensor mode num

    .pre_delay_frame = 2,    /* enter preview delay frame num */
    .cap_delay_frame = 3,    /* enter capture delay frame num */
    .video_delay_frame = 2,    /* enter normal_video delay frame num */
    .hs_video_delay_frame = 2,    /* enter high_speed_video delay frame num */
    .slim_video_delay_frame = 2,    /* enter slim_video delay frame num */
    .custom1_delay_frame = 2,    /* enter custom1 delay frame num */
    .custom2_delay_frame = 2,    /* enter custom2 delay frame num */
    .custom3_delay_frame = 2,    /* enter custom3 delay frame num */
    .custom4_delay_frame = 2,    /* enter custom4 delay frame num */
    .custom5_delay_frame = 2,    /* enter custom5 delay frame num */
    .custom6_delay_frame = 2,    /* enter custom6 delay frame num */
    .frame_time_delay_frame = 2,

    .isp_driving_current = ISP_DRIVING_8MA,
    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
    .mipi_sensor_type = MIPI_OPHY_NCSI2,
    .mipi_settle_delay_mode = 0,
    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_4CELL_HW_BAYER_B,
    .mclk = 24, /* mclk value, suggest 24 or 26 for 24Mhz or 26Mhz */
    .mipi_lane_num = SENSOR_MIPI_4_LANE,
    .i2c_addr_table = {0x20, 0xff},
    .i2c_speed = 400,
};

static struct imgsensor_struct imgsensor = {
    .mirror = IMAGE_NORMAL,
    .sensor_mode = IMGSENSOR_MODE_INIT,
    .shutter = 0x3D0,
    .gain = 0x100,
    .dummy_pixel = 0,
    .dummy_line = 0,
    .current_fps = 300,
    .autoflicker_en = KAL_FALSE,
    .test_pattern = KAL_FALSE,
    .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,
    .ihdr_mode = 0,
    .i2c_write_id = 0x20,
    .current_ae_effective_frame = 2,
    .max_shutter = 0xFFFFEE,
};

/* Sensor output window information*/
static struct SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[11] = {
    { 11584, 8688,    0,    0, 11584, 8688,  4000, 3000,    0,    0,  4000, 3000, 0,   0,   4000, 3000},// preview
    { 11584, 8688,    0,    0, 11584, 8688,  4000, 3000,    0,    0,  4000, 3000, 0,   0,   4000, 3000},// capture
    { 11584, 8688,    0, 1086, 11584, 6516,  4000, 2256,    0,    0,  4000, 2256, 0,   0,   4000, 2256},// normal_video
    { 11584, 8688,  416, 1320, 10752, 6048,  2688, 1512,    0,    0,  2688, 1512, 0,   0,   2688, 1512},// high_speed_video
    { 11584, 8688,   32, 1104, 11520, 6480,  2880, 1620,    0,    0,  2880, 1620, 0,   0,   2880, 1620},// slim_video
    { 11584, 8688,    0,    0, 11584, 8688,  4000, 3000,    0,    0,  4000, 3000, 0,   0,   4000, 3000},// custom1
    { 11584, 8688,    0,    0, 11584, 8688,  5792, 4344,    0,    0,  5792, 4344, 0,   0,   5792, 4344},// custom2
    { 11584, 8688,    0,    0, 11584, 8688, 11584, 8688,    0,    0, 11584, 8688, 0,   0,  11584, 8688},// custom3
    { 11584, 8688,   32, 1104, 11520, 6480,  2880, 1620,    0,    0,  2880, 1620, 0,   0,   2880, 1620},// custom4
    { 11584, 8688, 1792, 1344,  8000, 6000,  4000, 3000,    0,    0,  4000, 3000, 0,   0,   4000, 3000},// custom5
    { 11584, 8688,   32, 1104, 11520, 6480,  2880, 1620,    0,    0,  2880, 1620, 0,   0,   2880, 1620},// custom6
};

static struct SENSOR_VC_INFO_STRUCT SENSOR_VC_INFO[11] = {
    /* preview mode setting */
    {
        0x02, 0x0a, 0x0000, 0x0008, 0x40, 0x00,
        0x00, 0x2b, 0x0FA0, 0x0BB8, 0x00, 0x00, 0x0000, 0x0000,
        0x01, 0x2B, 0x02d0, 0x0878, 0x03, 0x00, 0x0000, 0x0000
    },
    /* capture mode setting */
    {
        0x02, 0x0a, 0x0000, 0x0008, 0x40, 0x00,
        0x00, 0x2b, 0x0FA0, 0x0BB8, 0x00, 0x00, 0x0000, 0x0000,
        0x01, 0x2B, 0x02d0, 0x0878, 0x03, 0x00, 0x0000, 0x0000
    },
    /* normal_video mode setting */
    {
        0x02, 0x0a, 0x0000, 0x0008, 0x40, 0x00,
        0x00, 0x2b, 0x0FA0, 0x08D0, 0x00, 0x00, 0x0000, 0x0000,
        0x01, 0x2B, 0x02d0, 0x0658, 0x03, 0x00, 0x0000, 0x0000
    },
    /* high_speed_video mode setting */
    {
        0x02, 0x0a, 0x0000, 0x0008, 0x40, 0x00,
        0x00, 0x2b, 0x0b40, 0x0654, 0x00, 0x00, 0x0000, 0x0000,
        0x01, 0x2b, 0x02d0, 0x0338, 0x03, 0x00, 0x0000, 0x0000
    },
    /* slim_video mode setting */
    {
        0x02, 0x0a, 0x0000, 0x0008, 0x40, 0x00,
        0x00, 0x2b, 0x0b40, 0x0654, 0x00, 0x00, 0x0000, 0x0000,
        0x01, 0x2b, 0x02d0, 0x0650, 0x03, 0x00, 0x0000, 0x0000
    },
    /* custom1 mode setting */
    {
        0x02, 0x0a, 0x0000, 0x0008, 0x40, 0x00,
        0x00, 0x2b, 0x0fa0, 0x0bb8, 0x00, 0x00, 0x0000, 0x0000,
        0x01, 0x2b, 0x02d0, 0x0878, 0x03, 0x00, 0x0000, 0x0000
    },
    /* custom2 mode setting */
    {
        0x02, 0x0a, 0x0000, 0x0008, 0x40, 0x00,
        0x00, 0x2b, 0x16a0, 0x10f8, 0x00, 0x00, 0x0000, 0x0000,
        0x01, 0x2b, 0x02d0, 0x0878, 0x03, 0x00, 0x0000, 0x0000
    },
    /* custom3 mode setting */
    {
        0x02, 0x0a, 0x0000, 0x0008, 0x40, 0x00,
        0x00, 0x2b, 0x1F40, 0x1770, 0x00, 0x00, 0x0000, 0x0000,
        0x01, 0x2b, 0x02d0, 0x043c, 0x03, 0x00, 0x0000, 0x0000
    },
    /* custom4 mode setting */
    {
        0x02, 0x0a, 0x0000, 0x0008, 0x40, 0x00,
        0x00, 0x2b, 0x0b40, 0x0654, 0x00, 0x00, 0x0000, 0x0000,
        0x01, 0x2b, 0x02d0, 0x0338, 0x03, 0x00, 0x0000, 0x0000
    },
    /* custom5 mode setting */
    {
        0x02, 0x0a, 0x0000, 0x0008, 0x40, 0x00,
        0x00, 0x2b, 0x0FA0, 0x0BB8, 0x00, 0x00, 0x0000, 0x0000,
        0x01, 0x2B, 0x03f0, 0x02f6, 0x03, 0x00, 0x0000, 0x0000
    },
    /* custom6 mode setting */
    {
        0x02, 0x0a, 0x0000, 0x0008, 0x40, 0x00,
        0x00, 0x2b, 0x0b40, 0x0654, 0x00, 0x00, 0x0000, 0x0000,
        0x01, 0x2b, 0x02d0, 0x0650, 0x03, 0x00, 0x0000, 0x0000
    },
};

/*PD information update*/
static struct SET_PD_BLOCK_INFO_T imgsensor_pd_info = {
    .i4OffsetX = 16,
    .i4OffsetY = 4,
    .i4PitchX = 16,
    .i4PitchY = 16,
    .i4PairNum = 8,
    .i4SubBlkW = 8,
    .i4SubBlkH = 4,
    .i4PosL = {
        {22, 6},
        {30, 6},
        {18,10},
        {26,10},
        {22,14},
        {30,14},
        {18,18},
        {26,18},
    },
    .i4PosR = {
        {21, 6},
        {29, 6},
        {17,10},
        {25,10},
        {21,14},
        {29,14},
        {17,18},
        {25,18},
    },
    .iMirrorFlip = 0,
    .i4BlockNumX = 360,
    .i4BlockNumY = 271,
    .i4LeFirst = 0,
    .i4Crop = { {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
    {0, 0}, {0, 0}, {0, 0}, {0, 0} },
};
static struct SET_PD_BLOCK_INFO_T imgsensor_pd_info_video = {
    .i4OffsetX = 16,
    .i4OffsetY = 4,
    .i4PitchX = 16,
    .i4PitchY = 16,
    .i4PairNum = 8,
    .i4SubBlkW = 8,
    .i4SubBlkH = 4,
    .i4PosL = {
        {22, 6},
        {30, 6},
        {18,10},
        {26,10},
        {22,14},
        {30,14},
        {18,18},
        {26,18},
    },
    .i4PosR = {
        {21, 6},
        {29, 6},
        {17,10},
        {25,10},
        {21,14},
        {29,14},
        {17,18},
        {25,18},
    },
    .iMirrorFlip = 0,
    .i4BlockNumX = 360,
    .i4BlockNumY = 203,
    .i4LeFirst = 0,
    .i4Crop = { {0, 0}, {0, 0}, {0, 544}, {0, 0}, {0, 0},
    {0, 0}, {0, 0}, {0, 0}, {0, 0} },
};
static struct SET_PD_BLOCK_INFO_T imgsensor_pd_info_slim_video = {
    .i4OffsetX = 0,
    .i4OffsetY = 2,
    .i4PitchX = 8,
    .i4PitchY = 8,
    .i4PairNum = 8,
    .i4SubBlkW = 4,
    .i4SubBlkH = 2,
    .i4PosL = {
        {3,3},
        {7,3},
        {1,5},
        {5,5},
        {3,7},
        {7,7},
        {1,9},
        {5,9},
    },
    .i4PosR = {
        {2,3},
        {6,3},
        {0,5},
        {4,5},
        {2,7},
        {6,7},
        {0,9},
        {4,9},
    },
    .iMirrorFlip = 0,
    .i4BlockNumX = 360,
    .i4BlockNumY = 202,
    .i4LeFirst = 0,
    .i4Crop = { {0, 0}, {0, 0}, {0,0 }, {0, 0}, {8, 280},
    {0, 0}, {0, 0}, {0, 0}, {0, 0} },
};
#define I2C_BUFFER_LEN 255 /* trans# max is 255, each 3 bytes */

static kal_uint16 table_write_cmos_sensor(kal_uint16 *para, kal_uint32 len)
{
	char puSendCmd[I2C_BUFFER_LEN];
	kal_uint32 tosend, index;
	kal_uint16 addr = 0, addr_last = 0, data;
	tosend = 0;
	index = 0;
	while (len > index) {
		addr = para[index];
		puSendCmd[tosend++] = (char)(addr >> 8);
		puSendCmd[tosend++] = (char)(addr & 0xFF);
		data = para[index + 1];
		puSendCmd[tosend++] = (char)(data & 0xFF);
		index += 2;
		addr_last = addr;
		/* Write when remain buffer size is less than 3 bytes
		 * or reach end of data
		 */
		if ((I2C_BUFFER_LEN - tosend) < 3
			|| index == len || addr != addr_last) {
			iBurstWriteReg_multi(puSendCmd,
				tosend,
				imgsensor.i2c_write_id,
				3,
				imgsensor_info.i2c_speed);
			tosend = 0;
		}
	}
	return 0;
}

static kal_uint16 read_cmos_sensor(kal_uint16 addr)
{
    kal_uint16 get_byte = 0;
    char pusendcmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
    iReadRegI2C(pusendcmd, 2, (u8 *)&get_byte, 1, imgsensor.i2c_write_id);
    return get_byte;
}

static void write_cmos_sensor(kal_uint16 addr, kal_uint8 para)
{
    char pusendcmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF),
            (char)(para & 0xFF)};
    iWriteRegI2C(pusendcmd, 3, imgsensor.i2c_write_id);
}

static void set_dummy(void)
{
    pr_debug("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
    // should be an even number
    imgsensor.frame_length = (imgsensor.frame_length  >> 1) << 1;
    write_cmos_sensor(0x3840, (imgsensor.frame_length >> 16) & 0xFF);
    write_cmos_sensor(0x380E, (imgsensor.frame_length >> 8) & 0xFF);
    write_cmos_sensor(0x380F, (imgsensor.frame_length >> 0) & 0xFF);
}

static void set_mirror_flip(kal_uint8 image_mirror)
{
	pr_debug("image_mirror = %d\n", image_mirror);
}

static void set_max_framerate(UINT16 framerate, kal_bool min_framelength_en)
{
    kal_uint32 frame_length = imgsensor.frame_length;

    pr_debug("framerate = %d, min framelength should enable %d\n", framerate, min_framelength_en);

    frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
    spin_lock(&imgsensor_drv_lock);
    if (frame_length >= imgsensor.min_frame_length)
        imgsensor.frame_length = frame_length;
    else
        imgsensor.frame_length = imgsensor.min_frame_length;

    imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;

    if (imgsensor.frame_length > imgsensor_info.max_frame_length) {
        imgsensor.frame_length = imgsensor_info.max_frame_length;
        imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
    }
    if (min_framelength_en)
        imgsensor.min_frame_length = imgsensor.frame_length;
    spin_unlock(&imgsensor_drv_lock);
    set_dummy();
}    /*    set_max_framerate  */

static int long_exposure_status = 0;

static void write_shutter(kal_uint32 shutter)
{
    kal_uint16 realtime_fps = 0;

    spin_lock(&imgsensor_drv_lock);
    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin) {
        imgsensor.frame_length = shutter + imgsensor_info.margin;
    } else {
        imgsensor.frame_length = imgsensor.min_frame_length;
    }
    if (imgsensor.frame_length > imgsensor_info.max_frame_length) {
        imgsensor.frame_length = imgsensor_info.max_frame_length;
    }
    spin_unlock(&imgsensor_drv_lock);
    if (shutter < imgsensor_info.min_shutter) {
        shutter = imgsensor_info.min_shutter;
    }
    //frame_length and shutter should be an even number.
    shutter = (shutter >> 1) << 1;
    imgsensor.frame_length = (imgsensor.frame_length  >> 1) << 1;
    if((last_shutter - 2 <= imgsensor.frame_length) && (imgsensor.frame_length <= last_shutter + 4) && (last_shutter > 0)) {
        imgsensor.frame_length = last_shutter + 6;
    }
    if (imgsensor.autoflicker_en) {
        realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
        if(realtime_fps >= 297 && realtime_fps <= 305){
            realtime_fps = 296;
            set_max_framerate(realtime_fps, 0);
        } else if(realtime_fps >= 147 && realtime_fps <= 150){
            realtime_fps = 146;
            set_max_framerate(realtime_fps, 0);
        }
    }
    if (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) {
        if (shutter > imgsensor.max_shutter) {
            shutter = imgsensor.max_shutter;
        }
        //Frame exposure mode customization for LE
        imgsensor.ae_frm_mode.frame_mode_1 = IMGSENSOR_AE_MODE_SE;
        imgsensor.ae_frm_mode.frame_mode_2 = IMGSENSOR_AE_MODE_SE;
        long_exposure_status = 1;
    } else if(long_exposure_status == 1){
        pr_debug("le shutter is %d exit\n",shutter);
        long_exposure_status = 0;
    }

    imgsensor.current_ae_effective_frame = 2;

    if(long_exposure_status == 0){
        write_cmos_sensor(0x3840, (imgsensor.frame_length >> 16) & 0xFF);
        write_cmos_sensor(0x380E, (imgsensor.frame_length >>  8) & 0xFF);
        write_cmos_sensor(0x380F, (imgsensor.frame_length >>  0) & 0xFF);
    }
    write_cmos_sensor(0x3500, (shutter >> 16) & 0xFF);
    write_cmos_sensor(0x3501, (shutter >>  8) & 0xFF);
    write_cmos_sensor(0x3502, (shutter >>  0) & 0xFF);
    // save the shutter,compare frame_length for the next time
    last_shutter = shutter;
    pr_debug("shutter =%d, framelength =%d, realtime_fps =%d\n", shutter,imgsensor.frame_length, realtime_fps);
}    /*    write_shutter  */

static void set_shutter(kal_uint32 shutter)
{
    unsigned long flags;
    spin_lock_irqsave(&imgsensor_drv_lock, flags);
    imgsensor.shutter = shutter;
    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
    write_shutter(shutter);
} /* set_shutter */

static kal_uint16 gain2reg(const kal_uint16 gain)
{
    kal_uint16 reg_gain = 0x0;
    reg_gain = gain * 256 / BASEGAIN;

    if(reg_gain < 256) {
        reg_gain = 256;
    }
    if(reg_gain > 15872) {
        reg_gain = 15872;
    }
    return (kal_uint16) reg_gain;
}

static kal_uint16 set_gain(kal_uint16 gain)
{
    kal_uint16 reg_gain;

    reg_gain = gain2reg(gain);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.gain = reg_gain;
    spin_unlock(&imgsensor_drv_lock);
    pr_debug("gain = %d, reg_gain = 0x%x\n ", gain, reg_gain);
    write_cmos_sensor(0x3508, (reg_gain >> 8) & 0xFF);
    write_cmos_sensor(0x3509, (reg_gain >> 0) & 0xFF);

    return gain;
} /* set_gain */
//only dual mode use it
static void set_shutter_frame_length(
                kal_uint16 shutter, kal_uint16 frame_length)
{
    unsigned long flags;
    kal_uint16 realtime_fps = 0;
    kal_int32 dummy_line = 0;
    spin_lock_irqsave(&imgsensor_drv_lock, flags);
    imgsensor.shutter = shutter;
    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
    spin_lock(&imgsensor_drv_lock);
    if (frame_length > 1)
        dummy_line = frame_length - imgsensor.frame_length;

    imgsensor.frame_length = imgsensor.frame_length + dummy_line;

    if (shutter > imgsensor.frame_length - imgsensor_info.margin)
        imgsensor.frame_length = shutter + imgsensor_info.margin;

    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
        imgsensor.frame_length = imgsensor_info.max_frame_length;
    spin_unlock(&imgsensor_drv_lock);

    shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;

    shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin))
                ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
    //frame_length and shutter should be an even number.
    shutter = (shutter >> 1) << 1;
    imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
    pr_debug("OVA0B40MIPIRAW shutter %d, last_shutter %d\n", shutter, last_shutter);
    if((last_shutter - 2 <= imgsensor.frame_length) && (imgsensor.frame_length <= last_shutter + 4) && (last_shutter > 0)) {
        imgsensor.frame_length = last_shutter + 6;
    }
    if (imgsensor.autoflicker_en) {
        realtime_fps = imgsensor.pclk
            / imgsensor.line_length * 10 / imgsensor.frame_length;

        if (realtime_fps >= 297 && realtime_fps <= 305)
            set_max_framerate(296, 0);
        else if (realtime_fps >= 147 && realtime_fps <= 150)
            set_max_framerate(146, 0);
        else {
            write_cmos_sensor(0x3840, (imgsensor.frame_length >> 16) & 0xFF);
            write_cmos_sensor(0x380e, (imgsensor.frame_length >>  8) & 0xFF);
            write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
        }
    } else {
        write_cmos_sensor(0x3840, (imgsensor.frame_length >> 16) & 0xFF);
        write_cmos_sensor(0x380e, (imgsensor.frame_length >> 8) & 0x7f);
        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
    }
    /* Update Shutter */
    write_cmos_sensor(0x3500, (shutter >> 16) & 0xFF);
    write_cmos_sensor(0x3501, (shutter >> 8) & 0xFF);
    write_cmos_sensor(0x3502, shutter & 0xFF);
    // save the shutter,compare frame_length for the next time
    last_shutter = shutter;
}    /* set_shutter_frame_length */

static kal_uint32 streaming_control(kal_bool enable)
{
    pr_debug("streaming_enable(0=Sw Standby,1=streaming): %d\n", enable);
    if (enable) {
        write_cmos_sensor(0x0100, 0x01);
    } else {
        write_cmos_sensor(0x0100, 0x00);
    }
    return ERROR_NONE;
}

static BYTE ova0b4_changzheng_common_data[CAMERA_EEPPROM_COMDATA_LENGTH] = { 0 };

static kal_uint16 read_ova0b4_changzheng_eeprom_module(kal_uint32 addr)
{
	kal_uint16 get_byte = 0;
	char pusendcmd[2] = { (char)(addr >> 8), (char)(addr & 0xFF) };
	iReadRegI2C(pusendcmd, 2, (u8 *) &get_byte, 1, EEPROM_I2C_ADDR);
	return get_byte;
}

static void read_ova0b4_changzheng_module_data(UINT32 sensor_id)
{
// ova0b4_changzheng_common_data
// length   : 64
// moduel&sensor&lens&vcm id : [0 ~ 7]
// QR       : [8 ~ 26]
// macro    : [28 ~ 29]
// inf      : [34 ~ 35]

	kal_uint16 idx = 0;
	kal_uint16 sn_length = 17;
	kal_uint32 sn_starAddr = 0xB0;
	kal_uint32 moduleAddr = 0x00;
	kal_uint32 sensorAddr = 0x06;
	kal_uint32 vcmAddr = 0x0A;
	kal_uint32 lensAddr = 0x08;
	kal_uint32 macAddr_lsb = 0x92;
	kal_uint32 macAddr_msb = 0x93;
	kal_uint32 infAddr_lsb = 0x94;
	kal_uint32 infAddr_msb = 0x95;

	memset(ova0b4_changzheng_common_data, 0,sizeof(ova0b4_changzheng_common_data));
	// QR
	for(idx = 0; idx < sn_length; idx++)
	{
		ova0b4_changzheng_common_data[8 + idx] = read_ova0b4_changzheng_eeprom_module(sn_starAddr + idx);
	}

	//macro
	ova0b4_changzheng_common_data[28] = read_ova0b4_changzheng_eeprom_module(macAddr_lsb);
	ova0b4_changzheng_common_data[29] = read_ova0b4_changzheng_eeprom_module(macAddr_msb);
	//inf
	ova0b4_changzheng_common_data[34] = read_ova0b4_changzheng_eeprom_module(infAddr_lsb);
	ova0b4_changzheng_common_data[35] = read_ova0b4_changzheng_eeprom_module(infAddr_msb);
	//module id
	ova0b4_changzheng_common_data[0] = read_ova0b4_changzheng_eeprom_module(moduleAddr);
	ova0b4_changzheng_common_data[1] = read_ova0b4_changzheng_eeprom_module(moduleAddr + 1);
	//sensor id
	ova0b4_changzheng_common_data[2] = read_ova0b4_changzheng_eeprom_module(sensorAddr);
	ova0b4_changzheng_common_data[3] = read_ova0b4_changzheng_eeprom_module(sensorAddr + 1);
	//lensid
	ova0b4_changzheng_common_data[4] = read_ova0b4_changzheng_eeprom_module(lensAddr);
	ova0b4_changzheng_common_data[5] = read_ova0b4_changzheng_eeprom_module(lensAddr + 1);
	//vcm
	ova0b4_changzheng_common_data[6] = read_ova0b4_changzheng_eeprom_module(vcmAddr);
	ova0b4_changzheng_common_data[7] = read_ova0b4_changzheng_eeprom_module(vcmAddr + 1);
	for (idx = 0; idx < CAMERA_EEPPROM_COMDATA_LENGTH; idx = idx + 4)
	{
		pr_debug("cam data: %02x %02x %02x %02x\n",
		       ova0b4_changzheng_common_data[idx],
		       ova0b4_changzheng_common_data[idx + 1],
		       ova0b4_changzheng_common_data[idx + 2],
		       ova0b4_changzheng_common_data[idx + 3]);
	}
}

static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
{
    kal_uint8 i = 0;
    kal_uint8 retry = 2;
    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
        spin_lock(&imgsensor_drv_lock);
        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
        spin_unlock(&imgsensor_drv_lock);
        do {
            *sensor_id = ((read_cmos_sensor(0x300B) << 8)
                    | read_cmos_sensor(0x300C));
            if (*sensor_id == imgsensor_info.sensor_id) {
                pr_info("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id, *sensor_id);
                imgsensor_info.module_id = 0x05;
                if (deviceInfo_register_value == 0x00) {
                    register_imgsensor_deviceinfo("Cam_r", DEVICE_VERSION_CHANGZHENG_OVA0B40Q, imgsensor_info.module_id);
                    deviceInfo_register_value=0x01;
                }
                read_ova0b4_changzheng_module_data(*sensor_id);
                return ERROR_NONE;
            }

            pr_info("Read sensor id fail, id: 0x%x\n",    imgsensor.i2c_write_id);
            retry--;
        } while (retry > 0);
        i++;
        retry = 2;
    }
    if (*sensor_id != imgsensor_info.sensor_id) {
        *sensor_id = 0xFFFFFFFF;
        return ERROR_SENSOR_CONNECT_FAIL;
    }
    return ERROR_NONE;
}

static void sensor_init(void)
{
    pr_debug("OVA0B40MIPIRAW sensor_init E\n");
    load_init_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW sensor_init X\n");
}	/* sensor_init */

static kal_uint32 open(void)
{
    kal_uint8 i = 0;
    kal_uint8 retry = 2;
    kal_uint16 sensor_id = 0;

    pr_debug("%s +\n", __func__);
    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
        spin_lock(&imgsensor_drv_lock);
        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
        spin_unlock(&imgsensor_drv_lock);
        do {
            sensor_id = ((read_cmos_sensor(0x300B) << 8)
                    | read_cmos_sensor(0x300C));
            if (sensor_id == imgsensor_info.sensor_id) {
                pr_info("i2c write id: 0x%x, sensor id: 0x%x\n",
                    imgsensor.i2c_write_id, sensor_id);
                break;
            }
            pr_info("Read sensor id fail, id: 0x%x\n",
                imgsensor.i2c_write_id);
            retry--;
        } while (retry > 0);
        i++;
        if (sensor_id == imgsensor_info.sensor_id)
            break;
        retry = 2;
    }
    if (imgsensor_info.sensor_id != sensor_id)
        return ERROR_SENSOR_CONNECT_FAIL;

    sensor_init();

    spin_lock(&imgsensor_drv_lock);

    imgsensor.autoflicker_en = KAL_FALSE;
    imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
    imgsensor.shutter = 0x3D0;
    imgsensor.gain = 0x100;
    imgsensor.pclk = imgsensor_info.preview.pclk;
    imgsensor.frame_length = imgsensor_info.preview.framelength;
    imgsensor.line_length = imgsensor_info.preview.linelength;
    imgsensor.min_frame_length = imgsensor_info.preview.framelength;
    imgsensor.dummy_pixel = 0;
    imgsensor.dummy_line = 0;
    imgsensor.ihdr_mode = 0;
    imgsensor.test_pattern = KAL_FALSE;
    imgsensor.current_fps = imgsensor_info.preview.max_framerate;
    spin_unlock(&imgsensor_drv_lock);
    pr_debug("%s -\n", __func__);

    return ERROR_NONE;
} /* open */

static kal_uint32 close(void)
{
    pr_debug("%s E\n", __func__);
    streaming_control(KAL_FALSE);
    last_shutter = 0; // reset
    return ERROR_NONE;
} /* close */

static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OVA0B40MIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
    imgsensor.pclk = imgsensor_info.preview.pclk;
    imgsensor.line_length = imgsensor_info.preview.linelength;
    imgsensor.frame_length = imgsensor_info.preview.framelength;
    imgsensor.min_frame_length = imgsensor_info.preview.framelength;
    imgsensor.current_fps = imgsensor_info.preview.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_preview_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* preview */

static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OVA0B40MIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
    imgsensor.pclk = imgsensor_info.capture.pclk;
    imgsensor.line_length = imgsensor_info.capture.linelength;
    imgsensor.frame_length = imgsensor_info.capture.framelength;
    imgsensor.min_frame_length = imgsensor_info.capture.framelength;
    imgsensor.current_fps = imgsensor_info.capture.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_capture_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* capture */

static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OVA0B40MIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
    imgsensor.pclk = imgsensor_info.normal_video.pclk;
    imgsensor.line_length = imgsensor_info.normal_video.linelength;
    imgsensor.frame_length = imgsensor_info.normal_video.framelength;
    imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
    imgsensor.current_fps = imgsensor_info.normal_video.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_normal_video_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* normal_video */

static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OVA0B40MIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
    imgsensor.pclk = imgsensor_info.high_speed_video.pclk;
    imgsensor.line_length = imgsensor_info.high_speed_video.linelength;
    imgsensor.frame_length = imgsensor_info.high_speed_video.framelength;
    imgsensor.min_frame_length = imgsensor_info.high_speed_video.framelength;
    imgsensor.current_fps = imgsensor_info.high_speed_video.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_high_speed_video_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* high_speed_video */

static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OVA0B40MIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
    imgsensor.pclk = imgsensor_info.slim_video.pclk;
    imgsensor.line_length = imgsensor_info.slim_video.linelength;
    imgsensor.frame_length = imgsensor_info.slim_video.framelength;
    imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
    imgsensor.current_fps = imgsensor_info.slim_video.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_slim_video_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* slim_video */

static kal_uint32 custom1(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OVA0B40MIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM1;
    imgsensor.pclk = imgsensor_info.custom1.pclk;
    imgsensor.line_length = imgsensor_info.custom1.linelength;
    imgsensor.frame_length = imgsensor_info.custom1.framelength;
    imgsensor.min_frame_length = imgsensor_info.custom1.framelength;
    imgsensor.current_fps = imgsensor_info.custom1.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_custom1_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* custom1 */

static kal_uint32 custom2(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OVA0B40MIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM2;
    imgsensor.pclk = imgsensor_info.custom2.pclk;
    imgsensor.line_length = imgsensor_info.custom2.linelength;
    imgsensor.frame_length = imgsensor_info.custom2.framelength;
    imgsensor.min_frame_length = imgsensor_info.custom2.framelength;
    imgsensor.current_fps = imgsensor_info.custom2.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_custom2_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* custom2 */

static kal_uint32 custom3(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OVA0B40MIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM3;
    imgsensor.pclk = imgsensor_info.custom3.pclk;
    imgsensor.line_length = imgsensor_info.custom3.linelength;
    imgsensor.frame_length = imgsensor_info.custom3.framelength;
    imgsensor.min_frame_length = imgsensor_info.custom3.framelength;
    imgsensor.current_fps = imgsensor_info.custom3.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_custom3_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* custom3 */

static kal_uint32 custom4(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OVA0B40MIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM4;
    imgsensor.pclk = imgsensor_info.custom4.pclk;
    imgsensor.line_length = imgsensor_info.custom4.linelength;
    imgsensor.frame_length = imgsensor_info.custom4.framelength;
    imgsensor.min_frame_length = imgsensor_info.custom4.framelength;
    imgsensor.current_fps = imgsensor_info.custom4.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_custom4_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* custom4 */

static kal_uint32 custom5(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OVA0B40MIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM5;
    imgsensor.pclk = imgsensor_info.custom5.pclk;
    imgsensor.line_length = imgsensor_info.custom5.linelength;
    imgsensor.frame_length = imgsensor_info.custom5.framelength;
    imgsensor.min_frame_length = imgsensor_info.custom5.framelength;
    imgsensor.current_fps = imgsensor_info.custom5.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_custom5_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* custom5 */

static kal_uint32 custom6(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OVA0B40MIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM6;
    imgsensor.pclk = imgsensor_info.custom6.pclk;
    imgsensor.line_length = imgsensor_info.custom6.linelength;
    imgsensor.frame_length = imgsensor_info.custom6.framelength;
    imgsensor.min_frame_length = imgsensor_info.custom6.framelength;
    imgsensor.current_fps = imgsensor_info.custom6.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_custom6_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OVA0B40MIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* custom6 */

static kal_uint32 get_resolution(
    MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
{
    pr_debug("%s E\n", __func__);
    sensor_resolution->SensorPreviewWidth =
        imgsensor_info.preview.grabwindow_width;
    sensor_resolution->SensorPreviewHeight =
        imgsensor_info.preview.grabwindow_height;

    sensor_resolution->SensorFullWidth =
        imgsensor_info.capture.grabwindow_width;
    sensor_resolution->SensorFullHeight =
        imgsensor_info.capture.grabwindow_height;

    sensor_resolution->SensorVideoWidth =
        imgsensor_info.normal_video.grabwindow_width;
    sensor_resolution->SensorVideoHeight =
        imgsensor_info.normal_video.grabwindow_height;

    sensor_resolution->SensorHighSpeedVideoWidth =
        imgsensor_info.high_speed_video.grabwindow_width;
    sensor_resolution->SensorHighSpeedVideoHeight =
        imgsensor_info.high_speed_video.grabwindow_height;

    sensor_resolution->SensorSlimVideoWidth =
        imgsensor_info.slim_video.grabwindow_width;
    sensor_resolution->SensorSlimVideoHeight =
        imgsensor_info.slim_video.grabwindow_height;

    sensor_resolution->SensorCustom1Width =
        imgsensor_info.custom1.grabwindow_width;
    sensor_resolution->SensorCustom1Height =
        imgsensor_info.custom1.grabwindow_height;

    sensor_resolution->SensorCustom2Width =
        imgsensor_info.custom2.grabwindow_width;
    sensor_resolution->SensorCustom2Height =
        imgsensor_info.custom2.grabwindow_height;

    sensor_resolution->SensorCustom3Width =
        imgsensor_info.custom3.grabwindow_width;
    sensor_resolution->SensorCustom3Height =
        imgsensor_info.custom3.grabwindow_height;
    sensor_resolution->SensorCustom4Width =
        imgsensor_info.custom4.grabwindow_width;
    sensor_resolution->SensorCustom4Height =
        imgsensor_info.custom4.grabwindow_height;
    sensor_resolution->SensorCustom5Width =
        imgsensor_info.custom5.grabwindow_width;
    sensor_resolution->SensorCustom5Height =
        imgsensor_info.custom5.grabwindow_height;
    sensor_resolution->SensorCustom6Width =
        imgsensor_info.custom6.grabwindow_width;
    sensor_resolution->SensorCustom6Height =
        imgsensor_info.custom6.grabwindow_height;
    return ERROR_NONE;
} /* get_resolution */

static kal_uint32 get_info(enum MSDK_SCENARIO_ID_ENUM scenario_id,
    MSDK_SENSOR_INFO_STRUCT *sensor_info,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("scenario_id = %d\n", scenario_id);

    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW;
    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
    sensor_info->SensorInterruptDelayLines = 4; /* not use */
    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
    sensor_info->SensorResetDelayCount = 5; /* not use */

    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
    sensor_info->SensorOutputDataFormat =
        imgsensor_info.sensor_output_dataformat;

    sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
    sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
    sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
    sensor_info->Custom1DelayFrame = imgsensor_info.custom1_delay_frame;
    sensor_info->Custom2DelayFrame = imgsensor_info.custom2_delay_frame;
    sensor_info->Custom3DelayFrame = imgsensor_info.custom3_delay_frame;
    sensor_info->Custom4DelayFrame = imgsensor_info.custom4_delay_frame;
    sensor_info->Custom5DelayFrame = imgsensor_info.custom5_delay_frame;
    sensor_info->Custom6DelayFrame = imgsensor_info.custom6_delay_frame;

    sensor_info->SensorMasterClockSwitch = 0; /* not use */
    sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;

    sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;
    sensor_info->AESensorGainDelayFrame =
        imgsensor_info.ae_sensor_gain_delay_frame;
    sensor_info->AEISPGainDelayFrame =
        imgsensor_info.ae_ispGain_delay_frame;
    sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
    sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
    sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
    sensor_info->PDAF_Support = 2;
    sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
    sensor_info->SensorClockFreq = imgsensor_info.mclk;
    sensor_info->SensorClockDividCount = 3; /* not use */
    sensor_info->SensorClockRisingCount = 0;
    sensor_info->SensorClockFallingCount = 2; /* not use */
    sensor_info->SensorPixelClockCount = 3; /* not use */
    sensor_info->SensorDataLatchCount = 2; /* not use */

    sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
    sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
    sensor_info->SensorWidthSampling = 0; /* 0 is default 1x */
    sensor_info->SensorHightSampling = 0; /* 0 is default 1x */
    sensor_info->SensorPacketECCOrder = 1;

    sensor_info->FrameTimeDelayFrame = imgsensor_info.frame_time_delay_frame;

    switch (scenario_id) {
    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
        sensor_info->SensorGrabStartX = imgsensor_info.preview.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.preview.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.preview.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
        sensor_info->SensorGrabStartX = imgsensor_info.capture.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.capture.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.capture.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
        sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
        sensor_info->SensorGrabStartX = imgsensor_info.high_speed_video.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.high_speed_video.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.high_speed_video.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_SLIM_VIDEO:
        sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_CUSTOM1:
        sensor_info->SensorGrabStartX = imgsensor_info.custom1.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.custom1.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.custom1.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_CUSTOM2:
        sensor_info->SensorGrabStartX = imgsensor_info.custom2.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.custom2.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.custom2.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_CUSTOM3:
        sensor_info->SensorGrabStartX = imgsensor_info.custom3.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.custom3.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.custom3.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_CUSTOM4:
        sensor_info->SensorGrabStartX = imgsensor_info.custom4.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.custom4.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.custom4.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_CUSTOM5:
        sensor_info->SensorGrabStartX = imgsensor_info.custom5.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.custom5.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.custom5.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_CUSTOM6:
        sensor_info->SensorGrabStartX = imgsensor_info.custom6.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.custom6.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.custom6.mipi_data_lp2hs_settle_dc;
        break;
    default:
        sensor_info->SensorGrabStartX = imgsensor_info.preview.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.preview.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.preview.mipi_data_lp2hs_settle_dc;
        break;
    }

    return ERROR_NONE;
}    /*    get_info  */


static kal_uint32 control(enum MSDK_SCENARIO_ID_ENUM scenario_id,
    MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("scenario_id = %d\n", scenario_id);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.current_scenario_id = scenario_id;
    spin_unlock(&imgsensor_drv_lock);
    switch (scenario_id) {
    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
        preview(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
        capture(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
        normal_video(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
        hs_video(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_SLIM_VIDEO:
        slim_video(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_CUSTOM1:
        custom1(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_CUSTOM2:
        custom2(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_CUSTOM3:
        custom3(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_CUSTOM4:
        custom4(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_CUSTOM5:
        custom5(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_CUSTOM6:
        custom6(image_window, sensor_config_data);
        break;
    default:
        pr_debug("Error ScenarioId setting");
        preview(image_window, sensor_config_data);
        return ERROR_INVALID_SCENARIO_ID;
    }

    return ERROR_NONE;
}    /* control() */

static kal_uint32 set_video_mode(UINT16 framerate)
{
    pr_debug("framerate = %d\n ", framerate);
    if (framerate == 0)
        return ERROR_NONE;
    spin_lock(&imgsensor_drv_lock);
    if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
        imgsensor.current_fps = 296;
    else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
        imgsensor.current_fps = 146;
    else
        imgsensor.current_fps = framerate;
    spin_unlock(&imgsensor_drv_lock);
    set_max_framerate(imgsensor.current_fps, 1);

    return ERROR_NONE;
}

static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
{
    spin_lock(&imgsensor_drv_lock);
    if (enable) {
        imgsensor.autoflicker_en = KAL_TRUE;
        pr_debug("enable! fps = %d", framerate);
    } else {
        imgsensor.autoflicker_en = KAL_FALSE;
    }
    spin_unlock(&imgsensor_drv_lock);

    return ERROR_NONE;
}

static kal_uint32 set_max_framerate_by_scenario(
        enum MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
{
    kal_uint32 frame_length;

    pr_debug("scenario_id = %d, framerate = %d\n", scenario_id, framerate);

    switch (scenario_id) {
    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
        frame_length = imgsensor_info.preview.pclk / framerate * 10
            / imgsensor_info.preview.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.preview.framelength)
            ? (frame_length - imgsensor_info.preview.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.preview.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
        frame_length = imgsensor_info.capture.pclk / framerate * 10
            / imgsensor_info.capture.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.capture.framelength)
            ? (frame_length - imgsensor_info.capture.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.capture.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
        frame_length = imgsensor_info.normal_video.pclk / framerate * 10
            / imgsensor_info.normal_video.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength)
            ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.normal_video.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
        frame_length = imgsensor_info.high_speed_video.pclk / framerate * 10
            / imgsensor_info.high_speed_video.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.high_speed_video.framelength)
            ? (frame_length - imgsensor_info.high_speed_video.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.high_speed_video.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_SLIM_VIDEO:
        frame_length = imgsensor_info.slim_video.pclk / framerate * 10
            / imgsensor_info.slim_video.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength)
            ? (frame_length - imgsensor_info.slim_video.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.slim_video.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_CUSTOM1:
        frame_length = imgsensor_info.custom1.pclk / framerate * 10
            / imgsensor_info.custom1.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.custom1.framelength)
            ? (frame_length - imgsensor_info.custom1.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.custom1.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_CUSTOM2:
        frame_length = imgsensor_info.custom2.pclk / framerate * 10
            / imgsensor_info.custom2.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.custom2.framelength)
            ? (frame_length - imgsensor_info.custom2.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.custom2.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_CUSTOM3:
        frame_length = imgsensor_info.custom3.pclk / framerate * 10
            / imgsensor_info.custom3.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.custom3.framelength)
            ? (frame_length - imgsensor_info.custom3.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.custom3.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_CUSTOM4:
        frame_length = imgsensor_info.custom4.pclk / framerate * 10
            / imgsensor_info.custom4.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.custom4.framelength)
            ? (frame_length - imgsensor_info.custom4.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.custom4.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
        set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_CUSTOM5:
        frame_length = imgsensor_info.custom5.pclk / framerate * 10
            / imgsensor_info.custom5.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.custom5.framelength)
            ? (frame_length - imgsensor_info.custom5.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.custom5.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
        set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_CUSTOM6:
        frame_length = imgsensor_info.custom6.pclk / framerate * 10
            / imgsensor_info.custom6.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.custom6.framelength)
            ? (frame_length - imgsensor_info.custom6.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.custom6.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
        set_dummy();
        }
        break;
    default:  /*coding with  preview scenario by default*/
        frame_length = imgsensor_info.preview.pclk / framerate * 10
            / imgsensor_info.preview.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line =
            (frame_length > imgsensor_info.preview.framelength)
            ? (frame_length - imgsensor_info.preview.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.preview.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        pr_debug("error scenario_id = %d, we use preview scenario\n",
            scenario_id);
        break;
    }
    return ERROR_NONE;
}

static kal_uint32 get_default_framerate_by_scenario(
        enum MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
{
    pr_debug("scenario_id = %d\n", scenario_id);

    switch (scenario_id) {
    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
        *framerate = imgsensor_info.preview.max_framerate;
        break;
    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
        *framerate = imgsensor_info.capture.max_framerate;
        break;
    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
        *framerate = imgsensor_info.normal_video.max_framerate;
        break;
    case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
        *framerate = imgsensor_info.high_speed_video.max_framerate;
        break;
    case MSDK_SCENARIO_ID_SLIM_VIDEO:
        *framerate = imgsensor_info.slim_video.max_framerate;
        break;
    case MSDK_SCENARIO_ID_CUSTOM1:
        *framerate = imgsensor_info.custom1.max_framerate;
        break;
    case MSDK_SCENARIO_ID_CUSTOM2:
        *framerate = imgsensor_info.custom2.max_framerate;
        break;
    case MSDK_SCENARIO_ID_CUSTOM3:
        *framerate = imgsensor_info.custom3.max_framerate;
        break;
    case MSDK_SCENARIO_ID_CUSTOM4:
        *framerate = imgsensor_info.custom4.max_framerate;
        break;
    case MSDK_SCENARIO_ID_CUSTOM5:
        *framerate = imgsensor_info.custom5.max_framerate;
        break;
    case MSDK_SCENARIO_ID_CUSTOM6:
        *framerate = imgsensor_info.custom6.max_framerate;
        break;
    default:
        break;
    }

    return ERROR_NONE;
}

static kal_uint32 set_test_pattern_mode(kal_bool enable)
{
    pr_debug("ova0 test_pattern mode!");
    if (enable) {
        write_cmos_sensor(0x350a, 0x00);
    } else {
        write_cmos_sensor(0x350a, 0x01);
    }

    spin_lock(&imgsensor_drv_lock);
    imgsensor.test_pattern = enable;
    spin_unlock(&imgsensor_drv_lock);
    return ERROR_NONE;
}

static kal_uint32 get_sensor_temperature(void)
{
    INT32 temperature = 0;

    write_cmos_sensor(0x4D12, 0x01);
    temperature = read_cmos_sensor(0x4D13);

    if(temperature >= 192) {
        temperature = 192 - temperature;
    }
    return temperature;
}

static kal_uint32 seamless_switch(enum MSDK_SCENARIO_ID_ENUM scenario_id,
        kal_uint32 shutter, kal_uint32 gain,
        kal_uint32 shutter_2ndframe, kal_uint32 gain_2ndframe)
{
    pr_debug("seamless switch to %d shutter%d gain%d!\n", scenario_id,shutter,gain);
    switch (scenario_id) {
    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
    {
        spin_lock(&imgsensor_drv_lock);
        imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
        imgsensor.pclk = imgsensor_info.preview.pclk;
        imgsensor.line_length = imgsensor_info.preview.linelength;
        imgsensor.frame_length = imgsensor_info.preview.framelength;
        imgsensor.min_frame_length = imgsensor_info.preview.framelength;
        imgsensor.autoflicker_en = KAL_FALSE;
        spin_unlock(&imgsensor_drv_lock);
        write_cmos_sensor(0x3208, 0x00);
        write_cmos_sensor(0x3046, 0x01);
        write_cmos_sensor(0x3016, 0xb1);
        write_cmos_sensor(0x3017, 0xf2);
        write_cmos_sensor(0x301f, 0x99);
        table_write_cmos_sensor(ova0b4_seamless_preview,sizeof(ova0b4_seamless_preview) / sizeof(kal_uint16));
        if (gain != 0) {
            set_gain(gain);
        }
        if (shutter != 0) {
            set_shutter(shutter);
        }
        write_cmos_sensor(0x3017, 0xf0);
        write_cmos_sensor(0x301f, 0x98);
        write_cmos_sensor(0x3016, 0xb0);
        write_cmos_sensor(0x3208, 0x10);
        write_cmos_sensor(0x3208, 0xa0);
    }
    break;
    case MSDK_SCENARIO_ID_CUSTOM5:
    {
        spin_lock(&imgsensor_drv_lock);
        imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM5;
        imgsensor.pclk = imgsensor_info.custom5.pclk;
        imgsensor.line_length = imgsensor_info.custom5.linelength;
        imgsensor.frame_length = imgsensor_info.custom5.framelength;
        imgsensor.min_frame_length = imgsensor_info.custom5.framelength;
        imgsensor.autoflicker_en = KAL_FALSE;
        spin_unlock(&imgsensor_drv_lock);

        write_cmos_sensor(0x3208, 0x00);
        write_cmos_sensor(0x3046, 0x01);
        write_cmos_sensor(0x3016, 0xb1);
        write_cmos_sensor(0x3017, 0xf2);
        write_cmos_sensor(0x301f, 0x99);
        table_write_cmos_sensor(ova0b4_seamless_custom5,sizeof(ova0b4_seamless_custom5) / sizeof(kal_uint16));
        if (gain != 0) {
            set_gain(gain);
        }
        if (shutter != 0) {
            set_shutter(shutter);
        }
        write_cmos_sensor(0x3017, 0xf0);
        write_cmos_sensor(0x301f, 0x98);
        write_cmos_sensor(0x3016, 0xb0);
        write_cmos_sensor(0x3208, 0x10);
        write_cmos_sensor(0x3208, 0xa0);
    }
    break;
    default:
    {
        pr_debug(
        "error! wrong setting in set_seamless_switch = %d",
        scenario_id);
        return 0xff;
        }
    }
    return 0;
}
static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
    UINT8 *feature_para, UINT32 *feature_para_len)
{
    UINT16 *feature_return_para_16 = (UINT16 *) feature_para;
    UINT16 *feature_data_16 = (UINT16 *) feature_para;
    UINT32 *feature_return_para_32 = (UINT32 *) feature_para;
    UINT32 *feature_data_32 = (UINT32 *) feature_para;
    unsigned long long *feature_data = (unsigned long long *) feature_para;
    struct SET_PD_BLOCK_INFO_T *PDAFinfo;
    struct SENSOR_WINSIZE_INFO_STRUCT *wininfo;
    struct SENSOR_VC_INFO_STRUCT *pvcinfo;
    uint32_t *pAeCtrls;
    uint32_t *pScenarios;
    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data
        = (MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;

    /*pr_debug("feature_id = %d\n", feature_id);*/
    switch (feature_id) {
    case SENSOR_FEATURE_GET_AWB_REQ_BY_SCENARIO:
        *(MUINT32 *)(uintptr_t)(*(feature_data + 1)) = 0;
        break;
    case SENSOR_FEATURE_GET_GAIN_RANGE_BY_SCENARIO:
        *(feature_data + 1) = imgsensor_info.min_gain;
        *(feature_data + 2) = imgsensor_info.max_gain;
        break;
    case SENSOR_FEATURE_GET_BASE_GAIN_ISO_AND_STEP:
        *(feature_data + 0) = imgsensor_info.min_gain_iso;
        *(feature_data + 1) = imgsensor_info.gain_step;
        *(feature_data + 2) = imgsensor_info.gain_type;
        break;
    case SENSOR_FEATURE_GET_MIN_SHUTTER_BY_SCENARIO:
        *(feature_data + 1) = imgsensor_info.min_shutter;
        *(feature_data + 2) = imgsensor_info.exp_step;
        break;
    case SENSOR_FEATURE_GET_OFFSET_TO_START_OF_EXPOSURE:
        *(MUINT32 *)(uintptr_t)(*(feature_data + 1)) = 1096800;
        break;
    case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ_BY_SCENARIO:
        switch (*feature_data) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.preview.pclk;
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.capture.pclk;
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.normal_video.pclk;
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.high_speed_video.pclk;
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.slim_video.pclk;
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom1.pclk;
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom2.pclk;
            break;
        case MSDK_SCENARIO_ID_CUSTOM3:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom3.pclk;
            break;
        case MSDK_SCENARIO_ID_CUSTOM4:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom4.pclk;
            break;
        case MSDK_SCENARIO_ID_CUSTOM5:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom5.pclk;
            break;
        case MSDK_SCENARIO_ID_CUSTOM6:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom6.pclk;
            break;
        default:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.preview.pclk;
            break;
        }
        break;
    case SENSOR_FEATURE_GET_PERIOD_BY_SCENARIO:
        switch (*feature_data) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.preview.framelength << 16)
                + imgsensor_info.preview.linelength;
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.capture.framelength << 16)
                + imgsensor_info.capture.linelength;
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.normal_video.framelength << 16)
                + imgsensor_info.normal_video.linelength;
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.high_speed_video.framelength << 16)
                + imgsensor_info.high_speed_video.linelength;
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.slim_video.framelength << 16)
                + imgsensor_info.slim_video.linelength;
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.custom1.framelength << 16)
                + imgsensor_info.custom1.linelength;
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.custom2.framelength << 16)
                + imgsensor_info.custom2.linelength;
            break;
        case MSDK_SCENARIO_ID_CUSTOM3:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.custom3.framelength << 16)
                + imgsensor_info.custom3.linelength;
            break;
        case MSDK_SCENARIO_ID_CUSTOM4:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.custom4.framelength << 16)
                + imgsensor_info.custom4.linelength;
            break;
        case MSDK_SCENARIO_ID_CUSTOM5:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.custom5.framelength << 16)
                + imgsensor_info.custom5.linelength;
            break;
        case MSDK_SCENARIO_ID_CUSTOM6:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.custom6.framelength << 16)
                + imgsensor_info.custom6.linelength;
            break;
        default:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.preview.framelength << 16)
                + imgsensor_info.preview.linelength;
            break;
        }
        break;

    case SENSOR_FEATURE_GET_PERIOD:
        *feature_return_para_16++ = imgsensor.line_length;
        *feature_return_para_16 = imgsensor.frame_length;
        *feature_para_len = 4;
        break;
    case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
        *feature_return_para_32 = imgsensor.pclk;
        *feature_para_len = 4;
        break;
    case SENSOR_FEATURE_SET_ESHUTTER:
         set_shutter(*feature_data);
        break;
    case SENSOR_FEATURE_SET_NIGHTMODE:
        //night_mode((BOOL) (*feature_data));
        break;
    case SENSOR_FEATURE_SET_GAIN:
        set_gain((UINT16) *feature_data);
        break;
    case SENSOR_FEATURE_SET_FLASHLIGHT:
        break;
    case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
        break;
    case SENSOR_FEATURE_SET_REGISTER:
        write_cmos_sensor(sensor_reg_data->RegAddr,
                    sensor_reg_data->RegData);
        break;
    case SENSOR_FEATURE_GET_REGISTER:
        sensor_reg_data->RegData =
            read_cmos_sensor(sensor_reg_data->RegAddr);
        break;
    case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
        *feature_return_para_32 = LENS_DRIVER_ID_DO_NOT_CARE;
        *feature_para_len = 4;
        break;
    case SENSOR_FEATURE_SET_VIDEO_MODE:
        set_video_mode(*feature_data);
        break;
    case SENSOR_FEATURE_CHECK_SENSOR_ID:
        get_imgsensor_id(feature_return_para_32);
        break;
    case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
        set_auto_flicker_mode((BOOL)*feature_data_16,
                      *(feature_data_16+1));
        break;
    case SENSOR_FEATURE_GET_TEMPERATURE_VALUE:
        *feature_return_para_32 = get_sensor_temperature();
        *feature_para_len = 4;
        break;
    case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
         set_max_framerate_by_scenario(
                (enum MSDK_SCENARIO_ID_ENUM)*feature_data,
                *(feature_data+1));
        break;
    case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
         get_default_framerate_by_scenario(
                (enum MSDK_SCENARIO_ID_ENUM)*(feature_data),
                (MUINT32 *)(uintptr_t)(*(feature_data+1)));
        break;
    case SENSOR_FEATURE_SET_TEST_PATTERN:
        set_test_pattern_mode((BOOL)*feature_data);
        break;
    case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE:
        *feature_return_para_32 = imgsensor_info.checksum_value;
        *feature_para_len = 4;
        break;
    case SENSOR_FEATURE_SET_FRAMERATE:
        pr_debug("current fps :%d\n", (UINT32)*feature_data_32);
        spin_lock(&imgsensor_drv_lock);
        imgsensor.current_fps = *feature_data_32;
        spin_unlock(&imgsensor_drv_lock);
        break;
    case SENSOR_FEATURE_SET_HDR:
        pr_debug("ihdr enable :%d\n", (BOOL)*feature_data_32);
        spin_lock(&imgsensor_drv_lock);
        imgsensor.ihdr_mode = *feature_data_32;
        spin_unlock(&imgsensor_drv_lock);
        break;
/****************************************************************************************************/
//LSCsensor modesensorwindow sizecapture size.
    case SENSOR_FEATURE_GET_CROP_INFO:
        pr_debug("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n",(UINT32)*feature_data);
        wininfo = (struct SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
        switch (*feature_data_32) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[5],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[6],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM3:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[7],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM4:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[8],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM5:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[9],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM6:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[10],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        default:
            memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        }
        break;
/***********************************************************************************************************************/
    case SENSOR_FEATURE_GET_PDAF_INFO:
        pr_debug("SENSOR_FEATURE_GET_PDAF_INFO scenarioId:%d\n",
        (UINT16)*feature_data);
        PDAFinfo =(struct SET_PD_BLOCK_INFO_T *)(uintptr_t)(*(feature_data + 1));
        switch (*feature_data) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW: //2x2 binning
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
        case MSDK_SCENARIO_ID_CUSTOM1:
            memcpy((void *)PDAFinfo,(void *)&imgsensor_pd_info,sizeof(struct SET_PD_BLOCK_INFO_T));
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            memcpy((void *)PDAFinfo,(void *)&imgsensor_pd_info_video,sizeof(struct SET_PD_BLOCK_INFO_T));
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
        case MSDK_SCENARIO_ID_CUSTOM6:
            memcpy((void *)PDAFinfo,(void *)&imgsensor_pd_info_slim_video,sizeof(struct SET_PD_BLOCK_INFO_T));
            break;
        default:
            break;
        }
        break;
    case SENSOR_FEATURE_GET_SENSOR_PDAF_CAPACITY:
        pr_debug("SENSOR_FEATURE_GET_SENSOR_PDAF_CAPACITY scenarioId:%d\n",
            (UINT16) *feature_data);
        switch (*feature_data) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data+1)) = 1;
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            *(MUINT32 *)(uintptr_t)(*(feature_data+1)) = 1;
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data+1)) = 1;
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data+1)) = 0;
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data+1)) = 1;
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            *(MUINT32 *)(uintptr_t)(*(feature_data+1)) = 1;
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            *(MUINT32 *)(uintptr_t)(*(feature_data+1)) = 1;
            break;
        case MSDK_SCENARIO_ID_CUSTOM6:
            *(MUINT32 *)(uintptr_t)(*(feature_data+1)) = 1;
            break;
        default:
            *(MUINT32 *)(uintptr_t)(*(feature_data+1)) = 0;
            break;
        }
        break;
    case SENSOR_FEATURE_GET_PDAF_DATA:
        pr_debug("SENSOR_FEATURE_GET_PDAF_DATA\n");
        imgsensor.pdaf_mode = *feature_data_16;
        break;
    case SENSOR_FEATURE_GET_PDAF_REG_SETTING:
        pr_debug("SENSOR_FEATURE_GET_PDAF_REG_SETTING %d",
            (*feature_para_len));
        break;
    case SENSOR_FEATURE_SET_PDAF_REG_SETTING:
        pr_debug("SENSOR_FEATURE_SET_PDAF_REG_SETTING %d",
            (*feature_para_len));
        break;
    case SENSOR_FEATURE_SET_PDAF:
        pr_debug("PDAF mode :%d\n", *feature_data_16);
        imgsensor.pdaf_mode = *feature_data_16;
        break;
    case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
        pr_debug("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",
            (UINT16)*feature_data,
            (UINT16)*(feature_data+1),
            (UINT16)*(feature_data+2));
        //ihdr_write_shutter_gain((UINT16) *feature_data,
        //            (UINT16) *(feature_data + 1),
        //            (UINT16) *(feature_data + 2));
        break;
    case SENSOR_FEATURE_SET_SHUTTER_FRAME_TIME:
        set_shutter_frame_length((UINT16) *feature_data, (UINT16) *(feature_data + 1));
        break;
    case SENSOR_FEATURE_GET_FRAME_CTRL_INFO_BY_SCENARIO:
        *(feature_data + 1) = 1;
        *(feature_data + 2) = imgsensor_info.margin;
        break;
    case SENSOR_FEATURE_SET_HDR_SHUTTER:
        pr_debug("SENSOR_FEATURE_SET_HDR_SHUTTER LE=%d, SE=%d\n",
            (UINT16)*feature_data, (UINT16)*(feature_data+1));
        //ihdr_write_shutter_gain((UINT16) *feature_data,
        //            (UINT16) *(feature_data + 1),
        //            (UINT16) *(feature_data + 2));
        break;
    case SENSOR_FEATURE_SET_STREAMING_SUSPEND:
        pr_debug("SENSOR_FEATURE_SET_STREAMING_SUSPEND\n");
        streaming_control(KAL_FALSE);
        break;
    case SENSOR_FEATURE_SET_STREAMING_RESUME:
        pr_debug("SENSOR_FEATURE_SET_STREAMING_RESUME, shutter:%llu\n",
            *feature_data);
        if (*feature_data != 0)
            set_shutter(*feature_data);
        streaming_control(KAL_TRUE);
        break;
    case SENSOR_FEATURE_GET_BINNING_TYPE:
        switch (*(feature_data + 1)) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_CUSTOM3:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_CUSTOM4:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_CUSTOM5:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_CUSTOM6:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        default:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        }
        pr_debug("SENSOR_FEATURE_GET_BINNING_TYPE AE_binning_type:%d,\n",
            *feature_return_para_32);
        *feature_para_len = 4;

        break;
    case SENSOR_FEATURE_GET_AE_EFFECTIVE_FRAME_FOR_LE:
        *feature_return_para_32 = imgsensor.current_ae_effective_frame;
        break;
    case SENSOR_FEATURE_GET_AE_FRAME_MODE_FOR_LE:
        memcpy(feature_return_para_32, &imgsensor.ae_frm_mode,
            sizeof(struct IMGSENSOR_AE_FRM_MODE));
        break;
    case SENSOR_FEATURE_GET_MIPI_PIXEL_RATE:
        switch (*feature_data) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.preview.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.capture.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.normal_video.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.high_speed_video.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.slim_video.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom1.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom2.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_CUSTOM3:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom3.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_CUSTOM4:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom4.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_CUSTOM5:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom5.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_CUSTOM6:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom6.mipi_pixel_rate;
            break;
        default:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.preview.mipi_pixel_rate;
            break;
        }
        break;

    case SENSOR_FEATURE_GET_VC_INFO:
        pr_debug("SENSOR_FEATURE_GET_VC_INFO %d\n",
            (UINT16)*feature_data);
        pvcinfo = (struct SENSOR_VC_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
        switch (*feature_data_32) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            memcpy((void *)pvcinfo, (void *)&SENSOR_VC_INFO[0],
                   sizeof(struct SENSOR_VC_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            memcpy((void *)pvcinfo, (void *)&SENSOR_VC_INFO[1],
                   sizeof(struct SENSOR_VC_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            memcpy((void *)pvcinfo, (void *)&SENSOR_VC_INFO[2],
                   sizeof(struct SENSOR_VC_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            memcpy((void *)pvcinfo, (void *)&SENSOR_VC_INFO[3],
                   sizeof(struct SENSOR_VC_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            memcpy((void *)pvcinfo, (void *)&SENSOR_VC_INFO[4],
                   sizeof(struct SENSOR_VC_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            memcpy((void *)pvcinfo, (void *)&SENSOR_VC_INFO[5],
                   sizeof(struct SENSOR_VC_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            memcpy((void *)pvcinfo, (void *)&SENSOR_VC_INFO[6],
                   sizeof(struct SENSOR_VC_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM5:
            memcpy((void *)pvcinfo, (void *)&SENSOR_VC_INFO[9],
                   sizeof(struct SENSOR_VC_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM6:
            memcpy((void *)pvcinfo, (void *)&SENSOR_VC_INFO[10],
                   sizeof(struct SENSOR_VC_INFO_STRUCT));
            break;
        default:
            memcpy((void *)pvcinfo, (void *)&SENSOR_VC_INFO[0],
                   sizeof(struct SENSOR_VC_INFO_STRUCT));
            break;
        }
        break;
    case SENSOR_FEATURE_SET_AWB_GAIN:
        break;
    case SENSOR_FEATURE_SET_LSC_TBL:
        break;
	case SENSOR_FEATURE_GET_MODULE_INFO:
		break;
	case SENSOR_FEATURE_GET_MODULE_SN:
		break;
	case SENSOR_FEATURE_SET_SENSOR_OTP:
		break;
	case SENSOR_FEATURE_CHECK_MODULE_ID:
		break;
	case SENSOR_FEATURE_GET_EEPROM_COMDATA:
		memcpy(feature_return_para_32, ova0b4_changzheng_common_data,
				CAMERA_EEPPROM_COMDATA_LENGTH);
		*feature_para_len = CAMERA_EEPPROM_COMDATA_LENGTH;
		break;
	case SENSOR_FEATURE_GET_EEPROM_STEREODATA:
		break;
	case SENSOR_FEATURE_GET_DISTORTIONPARAMS:
		break;
        case SENSOR_FEATURE_SEAMLESS_SWITCH:
        {
                pr_info("SENSOR_FEATURE_SEAMLESS_SWITCH");
                if ((feature_data + 1) != NULL)
                        pAeCtrls = (MUINT32 *)((uintptr_t)(*(feature_data + 1)));
                else
                        pr_info("warning! no ae_ctrl input");
                if (feature_data == NULL){
                        pr_info("error! input scenario is null!");
                        return ERROR_INVALID_SCENARIO_ID;
                }
                pr_info("call seamless_switch");
                if (pAeCtrls != NULL){
                        pr_info("call seamless_switch_arctrl");
                        seamless_switch((*feature_data),
                                        *pAeCtrls, *(pAeCtrls + 1),
                                        *(pAeCtrls + 4), *(pAeCtrls + 5));
                }else{
                        pr_info("call seamless_switch_null");
                        seamless_switch((*feature_data),0, 0, 0, 0);
                }
        }
                break;
        case SENSOR_FEATURE_GET_SEAMLESS_SCENARIOS:
                if ((feature_data + 1) != NULL)
                        pScenarios = (MUINT32 *)((uintptr_t)(*(feature_data + 1)));
                else{
                        pr_info("SENSOR_FEATURE_GET_SEAMLESS_SCENARIOS input pScenarios vector is NULL!\n");
                        return ERROR_INVALID_SCENARIO_ID;
                }
                switch (*feature_data) {
                case MSDK_SCENARIO_ID_CUSTOM5:
                        *pScenarios = MSDK_SCENARIO_ID_CAMERA_PREVIEW;
                        break;
                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
                        *pScenarios = MSDK_SCENARIO_ID_CUSTOM5;
                        break;
                default:
                        *pScenarios = 0xff;
                        break;
                }
                pr_info("SENSOR_FEATURE_GET_SEAMLESS_SCENARIOS %d %d\n", *feature_data,*pScenarios);
                break;
    default:
        break;
    }

    return ERROR_NONE;
} /* feature_control() */

static struct SENSOR_FUNCTION_STRUCT sensor_func = {
    open,
    get_info,
    get_resolution,
    feature_control,
    control,
    close
};

UINT32 OVA0B4_MIPI_RAW_CHANGZHENG_SensorInit(struct SENSOR_FUNCTION_STRUCT **pfFunc)
{
    if (pfFunc != NULL)
        *pfFunc = &sensor_func;
    return ERROR_NONE;
} /* OVA0B40_MIPI_RAW_SensorInit */

