/*
 * Copyright (C) 2016 MediaTek Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
 * generated by sensor driver assistant
 */

/*****************************************************************************
 *
 * Filename:
 * ---------
 *     ov16a1qmipiraw_Sensor.c
 *
 * Project:
 * --------
 *     ALPS
 *
 * Description:
 * ------------
 *     Source code of Sensor driver
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#define PFX "ov16a1q_mipi_raw"
#define pr_fmt(fmt) PFX "[%s] " fmt, __func__


#include <linux/videodev2.h>
#include <linux/i2c.h>
#include <linux/platform_device.h>
#include <linux/delay.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/fs.h>
#include <linux/atomic.h>
#include <linux/types.h>

#include "kd_camera_typedef.h"
#include "kd_imgsensor.h"
#include "kd_imgsensor_define.h"
#include "kd_imgsensor_errcode.h"

#include "ov16a1qmipiraw_Sensor.h"
#include "ov16a1qmipiraw_Setting.h"


#define LOG_INF(format, args...)    pr_debug(PFX "[%s] " format, __func__, ##args)

static DEFINE_SPINLOCK(imgsensor_drv_lock);
//#ifdef OPLUS_FEATURE_CAMERA_COMMON
extern void register_imgsensor_deviceinfo(char *name, char *version, u8 module_id);
static kal_uint8 deviceInfo_register_value = 0x00;
#define MODULE_ID_OFFSET 0x0000
#define EEPROM_I2C_ADDR 0xA8
#define DEVICE_VERSION  "OV16A1Q"
//#endif
static struct imgsensor_info_struct imgsensor_info = {
    .sensor_id = OV16A1Q_SENSOR_ID_DOKI,
    .module_id = 0x07, //0x07 Shine
    .checksum_value = 0x703C2F7E,
    .preview = {
        .pclk = 100000000,
        .linelength = 850,
        .framelength = 3920,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 2304,
        .grabwindow_height = 1728,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 290400000,
        .max_framerate = 300,
    },

    .capture = {
        .pclk = 100000000,
        .linelength = 850,
        .framelength = 3920,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 2304,
        .grabwindow_height = 1728,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 290400000,
        .max_framerate = 300,
    },

    .normal_video = {
        .pclk = 100000000,
        .linelength = 850,
        .framelength = 3920,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 2304,
        .grabwindow_height = 1728,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 290400000,
        .max_framerate = 300,
    },

    .high_speed_video = {
        .pclk = 100000000,
        .linelength = 850,
        .framelength = 980,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 1280,
        .grabwindow_height = 720,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 290400000,
        .max_framerate = 1200,
    },

    .slim_video = {
        .pclk = 100000000,
        .linelength = 850,
        .framelength = 3920,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 2304,
        .grabwindow_height = 1728,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 290400000,
        .max_framerate = 300,
    },

    .custom1 = {
        .pclk = 100000000,
        .linelength = 850,
        .framelength = 3920,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 2304,
        .grabwindow_height = 1728,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 290400000,
        .max_framerate = 300,
    },

    .custom2 = {
        .pclk = 100000000,
        .linelength = 850,
        .framelength = 3920,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 2304,
        .grabwindow_height = 1728,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 290400000,
        .max_framerate = 300,
    },

    .custom3 = {
        .pclk = 100000000,
        .linelength = 850,
        .framelength = 3920,
        .startx = 0,
        .starty = 0,
        .grabwindow_width  = 4608,
        .grabwindow_height = 3456,
        .mipi_data_lp2hs_settle_dc = 85,
        .mipi_pixel_rate = 580800000,
        .max_framerate = 300,
    },

    .margin = 8,
    .min_shutter = 8,
    .min_gain = 64,
    .max_gain = 992,
    .min_gain_iso = 100,
    .exp_step = 1,
    .gain_step = 1,
    .gain_type = 3,
    .max_frame_length = 0x7FFE,
    .ae_shut_delay_frame = 0,
    .ae_sensor_gain_delay_frame = 0,
    .ae_ispGain_delay_frame = 2,    /* isp gain delay frame for AE cycle */
    .ihdr_support = 0,    /* 1, support; 0,not support */
    .ihdr_le_firstline = 0,    /* 1,le first ; 0, se first */
    .temperature_support = 1,/* 1, support; 0,not support */
    .sensor_mode_num = 8,//support sensor mode num

    .pre_delay_frame = 2,    /* enter preview delay frame num */
    .cap_delay_frame = 3,    /* enter capture delay frame num */
    .video_delay_frame = 2,    /* enter normal_video delay frame num */
    .hs_video_delay_frame = 2,    /* enter high_speed_video delay frame num */
    .slim_video_delay_frame = 2,    /* enter slim_video delay frame num */
    .custom1_delay_frame = 2,    /* enter custom1 delay frame num */
    .custom2_delay_frame = 2,    /* enter custom2 delay frame num */
    .custom3_delay_frame = 2,    /* enter custom3 delay frame num */
    .frame_time_delay_frame = 2,

    .isp_driving_current = ISP_DRIVING_6MA,
    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
    .mipi_sensor_type = MIPI_OPHY_NCSI2,
    .mipi_settle_delay_mode = 0,
    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_4CELL_B,
    .mclk = 24, /* mclk value, suggest 24 or 26 for 24Mhz or 26Mhz */
    .mipi_lane_num = SENSOR_MIPI_4_LANE,
    .i2c_addr_table = { 0x20, 0xff},
    .i2c_speed = 400,
};

static struct imgsensor_struct imgsensor = {
    .mirror = IMAGE_NORMAL,
    .sensor_mode = IMGSENSOR_MODE_INIT,
    .shutter = 0x3D0,
    .gain = 0x100,
    .dummy_pixel = 0,
    .dummy_line = 0,
    .current_fps = 300,
    .autoflicker_en = KAL_FALSE,
    .test_pattern = KAL_FALSE,
    .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,
    .ihdr_mode = 0,
    .i2c_write_id = 0x20,
    .i2c_eeprom_id = 0xA8,
    .current_ae_effective_frame = 2,
    .max_shutter = 0x7FFFFE,
    .dpc_state = 0,
};

/* Sensor output window information*/
static struct SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[8] = {
    { 4608, 3456,    0,    0, 4608, 3456, 2304, 1728,    0,    0, 2304, 1728, 0,   0,   2304, 1728},// preview
    { 4608, 3456,    0,    0, 4608, 3456, 2304, 1728,    0,    0, 2304, 1728, 0,   0,   2304, 1728},// capture
    { 4608, 3456,    0,    0, 4608, 3456, 2304, 1728,    0,    0, 2304, 1728, 0,   0,   2304, 1728},// normal_video
    { 4608, 3456,    0,    0, 4608, 3456, 2304, 1728,  512,  504, 1280,  720, 0,   0,   1280,  720},// high_speed_video
    { 4608, 3456,    0,    0, 4608, 3456, 2304, 1728,    0,    0, 2304, 1728, 0,   0,   2304, 1728},// slim_video
    { 4608, 3456,    0,    0, 4608, 3456, 2304, 1728,    0,    0, 2304, 1728, 0,   0,   2304, 1728},// custom1 not use
    { 4608, 3456,    0,    0, 4608, 3456, 2304, 1728,    0,    0, 2304, 1728, 0,   0,   2304, 1728},// custom2 not use
    { 4608, 3456,    0,    0, 4608, 3456, 4608, 3456,    0,    0, 4608, 3456, 0,   0,   4608, 3456},// custom3 remosaic
};

#define I2C_BUFFER_LEN 255 /* trans# max is 255, each 3 bytes */

static kal_uint16 table_write_cmos_sensor(kal_uint16 *para, kal_uint32 len)
{
    char puSendCmd[I2C_BUFFER_LEN];
    kal_uint32 tosend, index;
    kal_uint16 addr = 0, addr_last = 0, data;
    tosend = 0;
    index = 0;
    while (len > index) {
        addr = para[index];
        puSendCmd[tosend++] = (char)(addr >> 8);
        puSendCmd[tosend++] = (char)(addr & 0xFF);
        data = para[index + 1];
        puSendCmd[tosend++] = (char)(data & 0xFF);
        index += 2;
        addr_last = addr;
        /* Write when remain buffer size is less than 3 bytes
         * or reach end of data
         */
        if ((I2C_BUFFER_LEN - tosend) < 3
            || index == len || addr != addr_last) {
            iBurstWriteReg_multi(puSendCmd,
                tosend,
                imgsensor.i2c_write_id,
                3,
                imgsensor_info.i2c_speed);
            tosend = 0;
        }
    }
    return 0;
}

static kal_uint16 read_cmos_sensor(kal_uint16 addr)
{
    kal_uint16 get_byte = 0;
    char pusendcmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
    iReadRegI2C(pusendcmd, 2, (u8 *)&get_byte, 1, imgsensor.i2c_write_id);
    return get_byte;
}

static void write_cmos_sensor(kal_uint16 addr, kal_uint8 para)
{
    char pusendcmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF),
            (char)(para & 0xFF)};
    iWriteRegI2C(pusendcmd, 3, imgsensor.i2c_write_id);
}

static void set_dummy(void)
{
    pr_debug("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);

    write_cmos_sensor(0x380C, (imgsensor.line_length >> 8) & 0xFF);
    write_cmos_sensor(0x380D, (imgsensor.line_length >> 0) & 0xFF);
    write_cmos_sensor(0x380E, (imgsensor.frame_length >> 8) & 0x7F);
    write_cmos_sensor(0x380F, (imgsensor.frame_length >> 0) & 0xFE);
}

static void set_mirror_flip(kal_uint8 image_mirror)
{
    pr_debug("image_mirror = %d\n", image_mirror);
}

static void set_max_framerate(UINT16 framerate, kal_bool min_framelength_en)
{
    kal_uint32 frame_length = imgsensor.frame_length;

    pr_debug("framerate = %d, min framelength should enable %d\n", framerate, min_framelength_en);

    frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
    spin_lock(&imgsensor_drv_lock);
    if (frame_length >= imgsensor.min_frame_length)
        imgsensor.frame_length = frame_length;
    else
        imgsensor.frame_length = imgsensor.min_frame_length;

    imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;

    if (imgsensor.frame_length > imgsensor_info.max_frame_length) {
        imgsensor.frame_length = imgsensor_info.max_frame_length;
        imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
    }
    if (min_framelength_en)
        imgsensor.min_frame_length = imgsensor.frame_length;
    spin_unlock(&imgsensor_drv_lock);
    set_dummy();
}    /*    set_max_framerate  */

static void write_shutter(kal_uint32 shutter)
{
    kal_uint16 realtime_fps = 0;
    kal_uint32 realtime_fl = 0;

    spin_lock(&imgsensor_drv_lock);
    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin) {
        imgsensor.frame_length = shutter + imgsensor_info.margin;
    } else {
        imgsensor.frame_length = imgsensor.min_frame_length;
    }
    if (imgsensor.frame_length > imgsensor_info.max_frame_length) {
        imgsensor.frame_length = imgsensor_info.max_frame_length;
    }
    realtime_fl = imgsensor.frame_length;
    spin_unlock(&imgsensor_drv_lock);
    if (shutter < imgsensor_info.min_shutter) {
        shutter = imgsensor_info.min_shutter;
    }

    write_cmos_sensor(0x3208, 0x00);

    if (imgsensor.autoflicker_en) {
        realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
        if(realtime_fps >= 297 && realtime_fps <= 305){
            realtime_fps = 296;
            set_max_framerate(realtime_fps, 0);
        } else if(realtime_fps >= 147 && realtime_fps <= 150){
            realtime_fps = 146;
            set_max_framerate(realtime_fps, 0);
        } else {
            //if(realtime_fl > 8200) {
            //    realtime_fl = 8200;
            //}

            realtime_fl = (realtime_fl  >> 1) << 1;
            write_cmos_sensor(0x380E, (realtime_fl >> 8) & 0xFF);
            write_cmos_sensor(0x380F, (realtime_fl >> 0) & 0xFF);
        }
    } else {
        //if(realtime_fl > 8200) {
        //    realtime_fl = 8200;
        //}

        realtime_fl = (realtime_fl  >> 1) << 1;
        write_cmos_sensor(0x380E, (realtime_fl >> 8) & 0xFF);
        write_cmos_sensor(0x380F, (realtime_fl >> 0) & 0xFF);
    }

    if (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) {
        shutter = imgsensor_info.max_frame_length - imgsensor_info.margin;
    }

    imgsensor.current_ae_effective_frame = 2;

    if(shutter >= 23470 && imgsensor.dpc_state != 1) {
        imgsensor.dpc_state = 1;
        write_cmos_sensor(0x5220, 0x00);
        write_cmos_sensor(0x5221, 0x00);
        write_cmos_sensor(0x5222, 0x5B);
        write_cmos_sensor(0x5223, 0xAE);
    } else if(imgsensor.dpc_state != 0){
        imgsensor.dpc_state = 0;
        write_cmos_sensor(0x5220, 0x00);
        write_cmos_sensor(0x5221, 0x65);
        write_cmos_sensor(0x5222, 0x10);
        write_cmos_sensor(0x5223, 0x00);
    }

    write_cmos_sensor(0x3500, (shutter >> 16) & 0x7F);
    write_cmos_sensor(0x3501, (shutter >> 8) & 0xFF);
    write_cmos_sensor(0x3502, (shutter >> 0) & 0xFE);

    write_cmos_sensor(0x3208, 0x10);
    write_cmos_sensor(0x3208, 0xA0);

    pr_debug("shutter =%d, framelength =%d, realtime_fps =%d\n", shutter,imgsensor.frame_length, realtime_fps);
}    /*    write_shutter  */

static void set_shutter(kal_uint32 shutter)
{
    unsigned long flags;
    spin_lock_irqsave(&imgsensor_drv_lock, flags);
    imgsensor.shutter = shutter;
    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
    write_shutter(shutter);
} /* set_shutter */

static kal_uint16 gain2reg(const kal_uint16 gain)
{
    kal_uint16 reg_gain = 0x0;
    reg_gain = gain * 256 / BASEGAIN;

    if(reg_gain < 256) {
        reg_gain = 256;
    }
    if(reg_gain > 3968) {
        reg_gain = 3968;
    }
    return (kal_uint16) reg_gain;
}

static kal_uint16 set_gain(kal_uint16 gain)
{
    kal_uint16 reg_gain;

    reg_gain = gain2reg(gain);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.gain = reg_gain;
    spin_unlock(&imgsensor_drv_lock);

    write_cmos_sensor(0x3208, 0x01);

    write_cmos_sensor(0x3508, (reg_gain >> 8) & 0x7F);
    write_cmos_sensor(0x3509, (reg_gain >> 0) & 0xFE);

    write_cmos_sensor(0x3208, 0x11);
    write_cmos_sensor(0x3208, 0xA1);

    pr_debug("gain = %d, reg_gain = 0x%x\n ", gain, reg_gain);
    return gain;
} /* set_gain */

static void set_shutter_frame_length(kal_uint16 shutter,
    kal_uint16 frame_length, kal_bool auto_extend_en)
{
    unsigned long flags;
    kal_int32 dummy_line = 0;
    spin_lock_irqsave(&imgsensor_drv_lock, flags);
    imgsensor.shutter = shutter;
    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
    spin_lock(&imgsensor_drv_lock);
    if (frame_length > 1)
        dummy_line = frame_length - imgsensor.frame_length;

    imgsensor.frame_length = imgsensor.frame_length + dummy_line;

    if (shutter > imgsensor.frame_length - imgsensor_info.margin)
        imgsensor.frame_length = shutter + imgsensor_info.margin;

    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
        imgsensor.frame_length = imgsensor_info.max_frame_length;
    spin_unlock(&imgsensor_drv_lock);
    set_shutter(shutter);
}    /* set_shutter_frame_length */

static kal_uint32 streaming_control(kal_bool enable)
{
    pr_debug("streaming_enable(0=Sw Standby,1=streaming): %d\n", enable);
    if (enable) {
        write_cmos_sensor(0x0100, 0x01);
    } else {
        write_cmos_sensor(0x0100, 0x00);
    }
    return ERROR_NONE;
}

#define FOUR_CELL_XTALK_CAL_SIZE 600
#define FOUR_CELL_XTALK_CAL_ADDR 0x0E00
static char FOUR_CELL_XTALK_CAL[FOUR_CELL_XTALK_CAL_SIZE + 2];

#define FOUR_CELL_DPC_SIZE 1920
#define FOUR_CELL_DPC_ADDR 0x1070
static char FOUR_CELL_DPC[FOUR_CELL_DPC_SIZE + 2];
 
static void read_4cell_from_eeprom(char* data, char* src, int addr, int len)
{
    char pu_send_cmd[2] = { (char)(addr >> 8), (char)(addr & 0xFF) };
    if (src[0] == 0 && src[1] == 0) {
        src[0] = (len & 0xff);
        src[1] = ((len >> 8) & 0xff);
        iReadRegI2C(pu_send_cmd, 2, &src[2], len, imgsensor.i2c_eeprom_id);
    }
    if (data != NULL) {
        memcpy(data, src, len + 2);
    }
}


//#ifdef OPLUS_FEATURE_CAMERA_COMMON
static BYTE ov16a1q_doki_common_data[CAMERA_EEPPROM_COMDATA_LENGTH] = { 0 };
static kal_uint16 read_ov16a1q_doki_eeprom_module(kal_uint32 addr)
{
    kal_uint16 get_byte = 0;
    char pusendcmd[2] = { (char)(addr >> 8), (char)(addr & 0xFF) };

    iReadRegI2C(pusendcmd, 2, (u8 *) &get_byte, 1, EEPROM_I2C_ADDR);

    return get_byte;
}

static void read_ov16a1q_doki_module_data(UINT32 sensor_id)
{
// ov16a1q_doki_common_data
// length   : 64
// QR       : [8 ~ 26]
// vcm      : [40 ~ 41]
// lensid   : [44 ~ 45]
// sensorid : [30 ~ 33]

    kal_uint16 idx = 0;
    kal_uint16 sn_length = 17;
    kal_uint32 sn_starAddr = 0xB0;
    kal_uint32 vcmAddr = 0x0C;
    kal_uint32 lensAddr = 0x08;

    memset(ov16a1q_doki_common_data, 0,sizeof(ov16a1q_doki_common_data));
    // QR
    for(idx = 0; idx < sn_length; idx++)
    {
        ov16a1q_doki_common_data[8 + idx] = read_ov16a1q_doki_eeprom_module(sn_starAddr + idx);
    }
    //vcm
    ov16a1q_doki_common_data[40] = read_ov16a1q_doki_eeprom_module(vcmAddr);
    ov16a1q_doki_common_data[41] = read_ov16a1q_doki_eeprom_module(vcmAddr + 1);
    //lensid
    ov16a1q_doki_common_data[44] = read_ov16a1q_doki_eeprom_module(lensAddr);
    ov16a1q_doki_common_data[45] = read_ov16a1q_doki_eeprom_module(lensAddr + 1);
    //sensor id
    ov16a1q_doki_common_data[30] = ((sensor_id) >> 24) & 0xff;
    ov16a1q_doki_common_data[31] = ((sensor_id) >> 16) & 0xff;
    ov16a1q_doki_common_data[32] = ((sensor_id) >> 8) & 0xff;
    ov16a1q_doki_common_data[33] = (sensor_id) & 0xff;

    for (idx = 0; idx < CAMERA_EEPPROM_COMDATA_LENGTH; idx = idx + 4)
        LOG_INF("cam data: %02x %02x %02x %02x\n",
               ov16a1q_doki_common_data[idx],
               ov16a1q_doki_common_data[idx + 1],
               ov16a1q_doki_common_data[idx + 2],
               ov16a1q_doki_common_data[idx + 3]);
}
//#endif  /* OPLUS_FEATURE_CAMERA_COMMON */

static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
{
    kal_uint8 i = 0;
    kal_uint8 retry = 2;
    kal_uint8 module_id = 0;
    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
        spin_lock(&imgsensor_drv_lock);
        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
        spin_unlock(&imgsensor_drv_lock);
        do {
            *sensor_id = ((read_cmos_sensor(0x300B) << 8)
                    | read_cmos_sensor(0x300C));
            if (*sensor_id == imgsensor_info.sensor_id) {
                pr_info("find sensor: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id, *sensor_id);
                module_id = read_ov16a1q_doki_eeprom_module(MODULE_ID_OFFSET);
                if (deviceInfo_register_value == 0) {
                    register_imgsensor_deviceinfo("Cam_f", DEVICE_VERSION, module_id);
                    deviceInfo_register_value = 1;
                }

                read_4cell_from_eeprom(NULL, FOUR_CELL_XTALK_CAL,
                    FOUR_CELL_XTALK_CAL_ADDR, FOUR_CELL_XTALK_CAL_SIZE);
                read_4cell_from_eeprom(NULL, FOUR_CELL_DPC,
                    FOUR_CELL_DPC_ADDR, FOUR_CELL_DPC_SIZE);

//#ifdef OPLUS_FEATURE_CAMERA_COMMON
                read_ov16a1q_doki_module_data(*sensor_id);
//#endif  /* OPLUS_FEATURE_CAMERA_COMMON */
                return ERROR_NONE;
            }

            pr_err("Read sensor id fail, id: 0x%x\n",    imgsensor.i2c_write_id);
            retry--;
        } while (retry > 0);
        i++;
        retry = 2;
    }
    if (*sensor_id != imgsensor_info.sensor_id) {
        *sensor_id = 0xFFFFFFFF;
        return ERROR_SENSOR_CONNECT_FAIL;
    }
    return ERROR_NONE;
}

static void sensor_init(void)
{
    pr_debug("OV16A1QMIPIRAW sensor_init E\n");
    load_init_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OV16A1QMIPIRAW sensor_init X\n");
}    /* sensor_init */

static kal_uint32 open(void)
{
    kal_uint8 i = 0;
    kal_uint8 retry = 2;
    kal_uint16 sensor_id = 0;

    pr_debug("%s +\n", __func__);
    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
        spin_lock(&imgsensor_drv_lock);
        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
        spin_unlock(&imgsensor_drv_lock);
        do {
            sensor_id = ((read_cmos_sensor(0x300B) << 8)
                    | read_cmos_sensor(0x300C));
            if (sensor_id == imgsensor_info.sensor_id) {
                pr_debug("i2c write id: 0x%x, sensor id: 0x%x\n",
                    imgsensor.i2c_write_id, sensor_id);
                break;
            }
            pr_err("Read sensor id fail, id: 0x%x\n",
                imgsensor.i2c_write_id);
            retry--;
        } while (retry > 0);
        i++;
        if (sensor_id == imgsensor_info.sensor_id)
            break;
        retry = 2;
    }
    if (imgsensor_info.sensor_id != sensor_id)
        return ERROR_SENSOR_CONNECT_FAIL;

    sensor_init();

    spin_lock(&imgsensor_drv_lock);

    imgsensor.autoflicker_en = KAL_FALSE;
    imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
    imgsensor.shutter = 0x3D0;
    imgsensor.gain = 0x100;
    imgsensor.pclk = imgsensor_info.preview.pclk;
    imgsensor.frame_length = imgsensor_info.preview.framelength;
    imgsensor.line_length = imgsensor_info.preview.linelength;
    imgsensor.min_frame_length = imgsensor_info.preview.framelength;
    imgsensor.dummy_pixel = 0;
    imgsensor.dummy_line = 0;
    imgsensor.ihdr_mode = 0;
    imgsensor.test_pattern = KAL_FALSE;
    imgsensor.current_fps = imgsensor_info.preview.max_framerate;
    spin_unlock(&imgsensor_drv_lock);
    pr_debug("%s -\n", __func__);

    return ERROR_NONE;
} /* open */

static kal_uint32 close(void)
{
    pr_debug("%s E\n", __func__);
    streaming_control(KAL_FALSE);
    return ERROR_NONE;
} /* close */

static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OV16A1QMIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
    imgsensor.pclk = imgsensor_info.preview.pclk;
    imgsensor.line_length = imgsensor_info.preview.linelength;
    imgsensor.frame_length = imgsensor_info.preview.framelength;
    imgsensor.min_frame_length = imgsensor_info.preview.framelength;
    imgsensor.current_fps = imgsensor_info.preview.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_preview_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OV16A1QMIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* preview */

static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OV16A1QMIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
    imgsensor.pclk = imgsensor_info.capture.pclk;
    imgsensor.line_length = imgsensor_info.capture.linelength;
    imgsensor.frame_length = imgsensor_info.capture.framelength;
    imgsensor.min_frame_length = imgsensor_info.capture.framelength;
    imgsensor.current_fps = imgsensor_info.capture.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_capture_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OV16A1QMIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* capture */

static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OV16A1QMIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
    imgsensor.pclk = imgsensor_info.normal_video.pclk;
    imgsensor.line_length = imgsensor_info.normal_video.linelength;
    imgsensor.frame_length = imgsensor_info.normal_video.framelength;
    imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
    imgsensor.current_fps = imgsensor_info.normal_video.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_normal_video_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OV16A1QMIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* normal_video */

static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OV16A1QMIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
    imgsensor.pclk = imgsensor_info.high_speed_video.pclk;
    imgsensor.line_length = imgsensor_info.high_speed_video.linelength;
    imgsensor.frame_length = imgsensor_info.high_speed_video.framelength;
    imgsensor.min_frame_length = imgsensor_info.high_speed_video.framelength;
    imgsensor.current_fps = imgsensor_info.high_speed_video.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_high_speed_video_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OV16A1QMIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* high_speed_video */

static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OV16A1QMIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
    imgsensor.pclk = imgsensor_info.slim_video.pclk;
    imgsensor.line_length = imgsensor_info.slim_video.linelength;
    imgsensor.frame_length = imgsensor_info.slim_video.framelength;
    imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
    imgsensor.current_fps = imgsensor_info.slim_video.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_slim_video_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OV16A1QMIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* slim_video */

static kal_uint32 custom1(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OV16A1QMIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM1;
    imgsensor.pclk = imgsensor_info.custom1.pclk;
    imgsensor.line_length = imgsensor_info.custom1.linelength;
    imgsensor.frame_length = imgsensor_info.custom1.framelength;
    imgsensor.min_frame_length = imgsensor_info.custom1.framelength;
    imgsensor.current_fps = imgsensor_info.custom1.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_custom1_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OV16A1QMIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* custom1 */

static kal_uint32 custom2(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OV16A1QMIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM2;
    imgsensor.pclk = imgsensor_info.custom2.pclk;
    imgsensor.line_length = imgsensor_info.custom2.linelength;
    imgsensor.frame_length = imgsensor_info.custom2.framelength;
    imgsensor.min_frame_length = imgsensor_info.custom2.framelength;
    imgsensor.current_fps = imgsensor_info.custom2.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_custom2_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OV16A1QMIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* custom2 */

static kal_uint32 custom3(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("OV16A1QMIPIRAW %s E\n", __func__);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM3;
    imgsensor.pclk = imgsensor_info.custom3.pclk;
    imgsensor.line_length = imgsensor_info.custom3.linelength;
    imgsensor.frame_length = imgsensor_info.custom3.framelength;
    imgsensor.min_frame_length = imgsensor_info.custom3.framelength;
    imgsensor.current_fps = imgsensor_info.custom3.max_framerate;
    imgsensor.dummy_line = 0;
    imgsensor.dummy_pixel = 0;
    imgsensor.autoflicker_en = KAL_FALSE;
    spin_unlock(&imgsensor_drv_lock);
    load_custom3_setting();
    set_mirror_flip(imgsensor.mirror);
    pr_debug("OV16A1QMIPIRAW %s X\n", __func__);
    return ERROR_NONE;
} /* custom3 */

static kal_uint32 get_resolution(
    MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
{
    pr_debug("%s E\n", __func__);
    sensor_resolution->SensorPreviewWidth =
        imgsensor_info.preview.grabwindow_width;
    sensor_resolution->SensorPreviewHeight =
        imgsensor_info.preview.grabwindow_height;

    sensor_resolution->SensorFullWidth =
        imgsensor_info.capture.grabwindow_width;
    sensor_resolution->SensorFullHeight =
        imgsensor_info.capture.grabwindow_height;

    sensor_resolution->SensorVideoWidth =
        imgsensor_info.normal_video.grabwindow_width;
    sensor_resolution->SensorVideoHeight =
        imgsensor_info.normal_video.grabwindow_height;

    sensor_resolution->SensorHighSpeedVideoWidth =
        imgsensor_info.high_speed_video.grabwindow_width;
    sensor_resolution->SensorHighSpeedVideoHeight =
        imgsensor_info.high_speed_video.grabwindow_height;

    sensor_resolution->SensorSlimVideoWidth =
        imgsensor_info.slim_video.grabwindow_width;
    sensor_resolution->SensorSlimVideoHeight =
        imgsensor_info.slim_video.grabwindow_height;

    sensor_resolution->SensorCustom1Width =
        imgsensor_info.custom1.grabwindow_width;
    sensor_resolution->SensorCustom1Height =
        imgsensor_info.custom1.grabwindow_height;

    sensor_resolution->SensorCustom2Width =
        imgsensor_info.custom2.grabwindow_width;
    sensor_resolution->SensorCustom2Height =
        imgsensor_info.custom2.grabwindow_height;

    sensor_resolution->SensorCustom3Width =
        imgsensor_info.custom3.grabwindow_width;
    sensor_resolution->SensorCustom3Height =
        imgsensor_info.custom3.grabwindow_height;

    return ERROR_NONE;
} /* get_resolution */

static kal_uint32 get_info(enum MSDK_SCENARIO_ID_ENUM scenario_id,
    MSDK_SENSOR_INFO_STRUCT *sensor_info,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("scenario_id = %d\n", scenario_id);

    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW;
    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
    sensor_info->SensorInterruptDelayLines = 4; /* not use */
    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
    sensor_info->SensorResetDelayCount = 5; /* not use */

    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
    sensor_info->SensorOutputDataFormat =
        imgsensor_info.sensor_output_dataformat;

    sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
    sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
    sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
    sensor_info->Custom1DelayFrame = imgsensor_info.custom1_delay_frame;
    sensor_info->Custom2DelayFrame = imgsensor_info.custom2_delay_frame;
    sensor_info->Custom3DelayFrame = imgsensor_info.custom3_delay_frame;

    sensor_info->SensorMasterClockSwitch = 0; /* not use */
    sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;

    sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;
    sensor_info->AESensorGainDelayFrame =
        imgsensor_info.ae_sensor_gain_delay_frame;
    sensor_info->AEISPGainDelayFrame =
        imgsensor_info.ae_ispGain_delay_frame;
    sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
    sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
    sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
    sensor_info->PDAF_Support = 0;
    sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
    sensor_info->SensorClockFreq = imgsensor_info.mclk;
    sensor_info->SensorClockDividCount = 3; /* not use */
    sensor_info->SensorClockRisingCount = 0;
    sensor_info->SensorClockFallingCount = 2; /* not use */
    sensor_info->SensorPixelClockCount = 3; /* not use */
    sensor_info->SensorDataLatchCount = 2; /* not use */

    sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
    sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
    sensor_info->SensorWidthSampling = 0; /* 0 is default 1x */
    sensor_info->SensorHightSampling = 0; /* 0 is default 1x */
    sensor_info->SensorPacketECCOrder = 1;

    sensor_info->FrameTimeDelayFrame = imgsensor_info.frame_time_delay_frame;

    switch (scenario_id) {
    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
        sensor_info->SensorGrabStartX = imgsensor_info.preview.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.preview.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.preview.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
        sensor_info->SensorGrabStartX = imgsensor_info.capture.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.capture.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.capture.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
        sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
        sensor_info->SensorGrabStartX = imgsensor_info.high_speed_video.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.high_speed_video.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.high_speed_video.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_SLIM_VIDEO:
        sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_CUSTOM1:
        sensor_info->SensorGrabStartX = imgsensor_info.custom1.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.custom1.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.custom1.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_CUSTOM2:
        sensor_info->SensorGrabStartX = imgsensor_info.custom2.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.custom2.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.custom2.mipi_data_lp2hs_settle_dc;
        break;
    case MSDK_SCENARIO_ID_CUSTOM3:
        sensor_info->SensorGrabStartX = imgsensor_info.custom3.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.custom3.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.custom3.mipi_data_lp2hs_settle_dc;
        break;
    default:
        sensor_info->SensorGrabStartX = imgsensor_info.preview.startx;
        sensor_info->SensorGrabStartY = imgsensor_info.preview.starty;
        sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount =
            imgsensor_info.preview.mipi_data_lp2hs_settle_dc;
        break;
    }

    return ERROR_NONE;
}    /*    get_info  */


static kal_uint32 control(enum MSDK_SCENARIO_ID_ENUM scenario_id,
    MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
    MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
    pr_debug("scenario_id = %d\n", scenario_id);
    spin_lock(&imgsensor_drv_lock);
    imgsensor.current_scenario_id = scenario_id;
    spin_unlock(&imgsensor_drv_lock);
    switch (scenario_id) {
    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
        preview(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
        capture(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
        normal_video(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
        hs_video(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_SLIM_VIDEO:
        slim_video(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_CUSTOM1:
        custom1(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_CUSTOM2:
        custom2(image_window, sensor_config_data);
        break;
    case MSDK_SCENARIO_ID_CUSTOM3:
        custom3(image_window, sensor_config_data);
        break;
    default:
        pr_warn("Error ScenarioId setting");
        preview(image_window, sensor_config_data);
        return ERROR_INVALID_SCENARIO_ID;
    }

    return ERROR_NONE;
}    /* control() */

static kal_uint32 set_video_mode(UINT16 framerate)
{
    pr_debug("framerate = %d\n ", framerate);
    if (framerate == 0)
        return ERROR_NONE;
    spin_lock(&imgsensor_drv_lock);
    if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
        imgsensor.current_fps = 296;
    else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
        imgsensor.current_fps = 146;
    else
        imgsensor.current_fps = framerate;
    spin_unlock(&imgsensor_drv_lock);
    set_max_framerate(imgsensor.current_fps, 1);

    return ERROR_NONE;
}

static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
{
    spin_lock(&imgsensor_drv_lock);
    if (enable) {
        imgsensor.autoflicker_en = KAL_TRUE;
        pr_debug("enable! fps = %d", framerate);
    } else {
        imgsensor.autoflicker_en = KAL_FALSE;
    }
    spin_unlock(&imgsensor_drv_lock);

    return ERROR_NONE;
}

static kal_uint32 set_max_framerate_by_scenario(
        enum MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
{
    kal_uint32 frame_length;

    pr_debug("scenario_id = %d, framerate = %d\n", scenario_id, framerate);

    switch (scenario_id) {
    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
        frame_length = imgsensor_info.preview.pclk / framerate * 10
            / imgsensor_info.preview.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.preview.framelength)
            ? (frame_length - imgsensor_info.preview.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.preview.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
        frame_length = imgsensor_info.capture.pclk / framerate * 10
            / imgsensor_info.capture.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.capture.framelength)
            ? (frame_length - imgsensor_info.capture.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.capture.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
        frame_length = imgsensor_info.normal_video.pclk / framerate * 10
            / imgsensor_info.normal_video.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength)
            ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.normal_video.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
        frame_length = imgsensor_info.high_speed_video.pclk / framerate * 10
            / imgsensor_info.high_speed_video.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.high_speed_video.framelength)
            ? (frame_length - imgsensor_info.high_speed_video.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.high_speed_video.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_SLIM_VIDEO:
        frame_length = imgsensor_info.slim_video.pclk / framerate * 10
            / imgsensor_info.slim_video.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength)
            ? (frame_length - imgsensor_info.slim_video.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.slim_video.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_CUSTOM1:
        frame_length = imgsensor_info.custom1.pclk / framerate * 10
            / imgsensor_info.custom1.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.custom1.framelength)
            ? (frame_length - imgsensor_info.custom1.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.custom1.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_CUSTOM2:
        frame_length = imgsensor_info.custom2.pclk / framerate * 10
            / imgsensor_info.custom2.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.custom2.framelength)
            ? (frame_length - imgsensor_info.custom2.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.custom2.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    case MSDK_SCENARIO_ID_CUSTOM3:
        frame_length = imgsensor_info.custom3.pclk / framerate * 10
            / imgsensor_info.custom3.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line = (frame_length > imgsensor_info.custom3.framelength)
            ? (frame_length - imgsensor_info.custom3.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.custom3.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        break;
    default:  /*coding with  preview scenario by default*/
        frame_length = imgsensor_info.preview.pclk / framerate * 10
            / imgsensor_info.preview.linelength;
        spin_lock(&imgsensor_drv_lock);
        imgsensor.dummy_line =
            (frame_length > imgsensor_info.preview.framelength)
            ? (frame_length - imgsensor_info.preview.framelength) : 0;
        imgsensor.frame_length = imgsensor_info.preview.framelength
            + imgsensor.dummy_line;
        imgsensor.min_frame_length = imgsensor.frame_length;
        spin_unlock(&imgsensor_drv_lock);
        if (imgsensor.frame_length > imgsensor.shutter){
            set_dummy();
        }
        pr_debug("error scenario_id = %d, we use preview scenario\n",
            scenario_id);
        break;
    }
    return ERROR_NONE;
}

static kal_uint32 get_default_framerate_by_scenario(
        enum MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
{
    pr_debug("scenario_id = %d\n", scenario_id);

    switch (scenario_id) {
    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
        *framerate = imgsensor_info.preview.max_framerate;
        break;
    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
        *framerate = imgsensor_info.capture.max_framerate;
        break;
    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
        *framerate = imgsensor_info.normal_video.max_framerate;
        break;
    case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
        *framerate = imgsensor_info.high_speed_video.max_framerate;
        break;
    case MSDK_SCENARIO_ID_SLIM_VIDEO:
        *framerate = imgsensor_info.slim_video.max_framerate;
        break;
    case MSDK_SCENARIO_ID_CUSTOM1:
        *framerate = imgsensor_info.custom1.max_framerate;
        break;
    case MSDK_SCENARIO_ID_CUSTOM2:
        *framerate = imgsensor_info.custom2.max_framerate;
        break;
    case MSDK_SCENARIO_ID_CUSTOM3:
        *framerate = imgsensor_info.custom3.max_framerate;
        break;
    default:
        break;
    }

    return ERROR_NONE;
}

static kal_uint32 set_test_pattern_mode(kal_bool enable)
{
    pr_debug("enable: %d\n", enable);

    if (enable) {
        write_cmos_sensor(0x350a, 0x00);
    } else {
        write_cmos_sensor(0x350a, 0x01);
    }
    spin_lock(&imgsensor_drv_lock);
    imgsensor.test_pattern = enable;
    spin_unlock(&imgsensor_drv_lock);
    return ERROR_NONE;
}

static kal_uint32 get_sensor_temperature(void)
{
    INT32 temperature = 0;

    write_cmos_sensor(0x4D12, 0x01);
    temperature = read_cmos_sensor(0x4D13);

    if(temperature >= 192) {
        temperature = 192 - temperature;
    }
    return temperature;
}

static kal_uint32 ana_gain_table_16x[] = {
     1024,  1088,  1152,  1216, 
     1280,  1344,  1408,  1472, 
     1536,  1600,  1664,  1728, 
     1792,  1856,  1920,  1984, 
     2048,  2176,  2304,  2432, 
     2560,  2688,  2816,  2944, 
     3072,  3200,  3328,  3456, 
     3584,  3712,  3840,  3968, 
     4096,  4352,  4608,  4864, 
     5120,  5376,  5632,  5888, 
     6144,  6400,  6656,  6912, 
     7168,  7424,  7680,  7936, 
     8192,  8704,  9216,  9728, 
    10240, 10752, 11264, 11776, 
    12288, 12800, 13312, 13824, 
    14336, 14848, 15360, 15872
};

static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
    UINT8 *feature_para, UINT32 *feature_para_len)
{
    UINT16 *feature_return_para_16 = (UINT16 *) feature_para;
    UINT16 *feature_data_16 = (UINT16 *) feature_para;
    UINT32 *feature_return_para_32 = (UINT32 *) feature_para;
    UINT32 *feature_data_32 = (UINT32 *) feature_para;
    unsigned long long *feature_data = (unsigned long long *) feature_para;
    struct SENSOR_WINSIZE_INFO_STRUCT *wininfo;
    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data
        = (MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;

    /*pr_debug("feature_id = %d\n", feature_id);*/
    switch (feature_id) {
    case SENSOR_FEATURE_GET_ANA_GAIN_TABLE:
        if ((void *)(uintptr_t) (*(feature_data + 0)) == 0) {
            *(feature_data + 0) =
                sizeof(ana_gain_table_16x);
                pr_debug("ana_gain_table_16x size = %d\n", sizeof(ana_gain_table_16x));
        } else {
            pr_debug("befor memccpy ana_gain_table_16x \n");
            memcpy((void *)(uintptr_t) (*(feature_data + 1)),
            (void *)ana_gain_table_16x,
            sizeof(ana_gain_table_16x));
            pr_debug("after memccpy ana_gain_table_16x \n");

        }
        break;
    case SENSOR_FEATURE_GET_AWB_REQ_BY_SCENARIO:
        *(MUINT32 *)(uintptr_t)(*(feature_data + 1)) = 0;
        break;
    case SENSOR_FEATURE_GET_GAIN_RANGE_BY_SCENARIO:
        *(feature_data + 1) = imgsensor_info.min_gain;
        *(feature_data + 2) = imgsensor_info.max_gain;
        break;
    case SENSOR_FEATURE_GET_BASE_GAIN_ISO_AND_STEP:
        *(feature_data + 0) = imgsensor_info.min_gain_iso;
        *(feature_data + 1) = imgsensor_info.gain_step;
        *(feature_data + 2) = imgsensor_info.gain_type;
        break;
    case SENSOR_FEATURE_GET_MIN_SHUTTER_BY_SCENARIO:
        *(feature_data + 1) = imgsensor_info.min_shutter;
        *(feature_data + 2) = imgsensor_info.exp_step;
        break;
    case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ_BY_SCENARIO:
        switch (*feature_data) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.preview.pclk;
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.capture.pclk;
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.normal_video.pclk;
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.high_speed_video.pclk;
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.slim_video.pclk;
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom1.pclk;
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom2.pclk;
            break;
        case MSDK_SCENARIO_ID_CUSTOM3:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom3.pclk;
            break;
        default:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.preview.pclk;
            break;
        }
        break;
    case SENSOR_FEATURE_GET_PERIOD_BY_SCENARIO:
        switch (*feature_data) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.preview.framelength << 16)
                + imgsensor_info.preview.linelength;
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.capture.framelength << 16)
                + imgsensor_info.capture.linelength;
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.normal_video.framelength << 16)
                + imgsensor_info.normal_video.linelength;
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.high_speed_video.framelength << 16)
                + imgsensor_info.high_speed_video.linelength;
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.slim_video.framelength << 16)
                + imgsensor_info.slim_video.linelength;
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.custom1.framelength << 16)
                + imgsensor_info.custom1.linelength;
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.custom2.framelength << 16)
                + imgsensor_info.custom2.linelength;
            break;
        case MSDK_SCENARIO_ID_CUSTOM3:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.custom3.framelength << 16)
                + imgsensor_info.custom3.linelength;
            break;
        default:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
            = (imgsensor_info.preview.framelength << 16)
                + imgsensor_info.preview.linelength;
            break;
        }
        break;

    case SENSOR_FEATURE_GET_PERIOD:
        *feature_return_para_16++ = imgsensor.line_length;
        *feature_return_para_16 = imgsensor.frame_length;
        *feature_para_len = 4;
        break;
    case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
        *feature_return_para_32 = imgsensor.pclk;
        *feature_para_len = 4;
        break;
    case SENSOR_FEATURE_SET_ESHUTTER:
         set_shutter(*feature_data);
        break;
    case SENSOR_FEATURE_SET_NIGHTMODE:
        //night_mode((BOOL) (*feature_data));
        break;
    case SENSOR_FEATURE_SET_GAIN:
        set_gain((UINT16) *feature_data);
        break;
    case SENSOR_FEATURE_SET_FLASHLIGHT:
        break;
    case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
        break;
    case SENSOR_FEATURE_SET_REGISTER:
        write_cmos_sensor(sensor_reg_data->RegAddr,
                    sensor_reg_data->RegData);
        break;
    case SENSOR_FEATURE_GET_REGISTER:
        sensor_reg_data->RegData =
            read_cmos_sensor(sensor_reg_data->RegAddr);
        break;
    case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
        *feature_return_para_32 = LENS_DRIVER_ID_DO_NOT_CARE;
        *feature_para_len = 4;
        break;
    case SENSOR_FEATURE_SET_VIDEO_MODE:
        set_video_mode(*feature_data);
        break;
    case SENSOR_FEATURE_CHECK_SENSOR_ID:
        get_imgsensor_id(feature_return_para_32);
        break;
    case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
        set_auto_flicker_mode((BOOL)*feature_data_16,
                      *(feature_data_16+1));
        break;
    case SENSOR_FEATURE_GET_TEMPERATURE_VALUE:
        *feature_return_para_32 = get_sensor_temperature();
        *feature_para_len = 4;
        break;
    case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
         set_max_framerate_by_scenario(
                (enum MSDK_SCENARIO_ID_ENUM)*feature_data,
                *(feature_data+1));
        break;
    case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
         get_default_framerate_by_scenario(
                (enum MSDK_SCENARIO_ID_ENUM)*(feature_data),
                (MUINT32 *)(uintptr_t)(*(feature_data+1)));
        break;
    case SENSOR_FEATURE_SET_TEST_PATTERN:
        set_test_pattern_mode((BOOL)*feature_data);
        break;
    case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE:
        *feature_return_para_32 = imgsensor_info.checksum_value;
        *feature_para_len = 4;
        break;
    case SENSOR_FEATURE_SET_FRAMERATE:
        pr_debug("current fps :%d\n", (UINT32)*feature_data_32);
        spin_lock(&imgsensor_drv_lock);
        imgsensor.current_fps = *feature_data_32;
        spin_unlock(&imgsensor_drv_lock);
        break;
    case SENSOR_FEATURE_SET_HDR:
        pr_debug("ihdr enable :%d\n", (BOOL)*feature_data_32);
        spin_lock(&imgsensor_drv_lock);
        imgsensor.ihdr_mode = *feature_data_32;
        spin_unlock(&imgsensor_drv_lock);
        break;
    case SENSOR_FEATURE_GET_CROP_INFO:
        pr_debug("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n",
            (UINT32)*feature_data);
        wininfo = (struct SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));

        switch (*feature_data_32) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            memcpy((void *)wininfo,
            (void *)&imgsensor_winsize_info[0],
            sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            memcpy((void *)wininfo,
            (void *)&imgsensor_winsize_info[1],
            sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            memcpy((void *)wininfo,
            (void *)&imgsensor_winsize_info[2],
            sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            memcpy((void *)wininfo,
            (void *)&imgsensor_winsize_info[3],
            sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            memcpy((void *)wininfo,
            (void *)&imgsensor_winsize_info[4],
            sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            memcpy((void *)wininfo,
            (void *)&imgsensor_winsize_info[5],
            sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            memcpy((void *)wininfo,
            (void *)&imgsensor_winsize_info[6],
            sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        case MSDK_SCENARIO_ID_CUSTOM3:
            memcpy((void *)wininfo,
            (void *)&imgsensor_winsize_info[7],
            sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        default:
            memcpy((void *)wininfo,
            (void *)&imgsensor_winsize_info[0],
            sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
            break;
        }
        break;
    case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
        pr_debug("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",
            (UINT16)*feature_data,
            (UINT16)*(feature_data+1),
            (UINT16)*(feature_data+2));
        //ihdr_write_shutter_gain((UINT16) *feature_data,
        //            (UINT16) *(feature_data + 1),
        //            (UINT16) *(feature_data + 2));
        break;
    case SENSOR_FEATURE_SET_SHUTTER_FRAME_TIME:
        set_shutter_frame_length((UINT16) (*feature_data),
                    (UINT16) (*(feature_data + 1)),
                    (BOOL) (*(feature_data + 2)));
        break;
    case SENSOR_FEATURE_GET_FRAME_CTRL_INFO_BY_SCENARIO:
        *(feature_data + 1) = 1;
        *(feature_data + 2) = imgsensor_info.margin;
        break;
    case SENSOR_FEATURE_SET_HDR_SHUTTER:
        pr_debug("SENSOR_FEATURE_SET_HDR_SHUTTER LE=%d, SE=%d\n",
            (UINT16)*feature_data, (UINT16)*(feature_data+1));
        //ihdr_write_shutter_gain((UINT16) *feature_data,
        //            (UINT16) *(feature_data + 1),
        //            (UINT16) *(feature_data + 2));
        break;
    case SENSOR_FEATURE_GET_4CELL_DATA:
    {
        int type = (kal_uint16)(*feature_data);
        char* data = (char*)(uintptr_t)(*(feature_data+1));        
        if (data == NULL) {
            break;
        }
        if(type == FOUR_CELL_CAL_TYPE_XTALK_CAL) {
            read_4cell_from_eeprom(data, FOUR_CELL_XTALK_CAL, 
                FOUR_CELL_XTALK_CAL_ADDR, FOUR_CELL_XTALK_CAL_SIZE);
            pr_debug("Read xtalk_cal = %02x %02x %02x %02x %02x %02x\n",
                (UINT16)data[0], (UINT16)data[1],
                (UINT16)data[2], (UINT16)data[3],
                (UINT16)data[4], (UINT16)data[5]);
            break;
        }
        if(type == FOUR_CELL_CAL_TYPE_DPC) {
            read_4cell_from_eeprom(data, FOUR_CELL_DPC, 
                FOUR_CELL_DPC_ADDR, FOUR_CELL_DPC_SIZE);
            pr_debug("Read dpc = %02x %02x %02x %02x %02x %02x\n",
                (UINT16)data[0], (UINT16)data[1],
                (UINT16)data[2], (UINT16)data[3],
                (UINT16)data[4], (UINT16)data[5]);
            break;
        }
        break;
    }
    case SENSOR_FEATURE_SET_STREAMING_SUSPEND:
        pr_debug("SENSOR_FEATURE_SET_STREAMING_SUSPEND\n");
        streaming_control(KAL_FALSE);
        break;
    case SENSOR_FEATURE_SET_STREAMING_RESUME:
        pr_debug("SENSOR_FEATURE_SET_STREAMING_RESUME, shutter:%llu\n",
            *feature_data);
        if (*feature_data != 0)
            set_shutter(*feature_data);
        streaming_control(KAL_TRUE);
        break;
    case SENSOR_FEATURE_GET_BINNING_TYPE:
        switch (*(feature_data + 1)) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            *feature_return_para_32 = 2857; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            *feature_return_para_32 = 2; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            *feature_return_para_32 = 2; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            *feature_return_para_32 = 2; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            *feature_return_para_32 = 2; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        case MSDK_SCENARIO_ID_CUSTOM3:
            *feature_return_para_32 = 1; /*BINNING_AVERAGED*/
            break;
        default:
            *feature_return_para_32 = 2; /*BINNING_AVERAGED*/
            break;
        }
        pr_debug("SENSOR_FEATURE_GET_BINNING_TYPE AE_binning_type:%d,\n",
            *feature_return_para_32);
        *feature_para_len = 4;

        break;
    case SENSOR_FEATURE_GET_AE_EFFECTIVE_FRAME_FOR_LE:
        *feature_return_para_32 = imgsensor.current_ae_effective_frame;
        break;
    case SENSOR_FEATURE_GET_AE_FRAME_MODE_FOR_LE:
        memcpy(feature_return_para_32, &imgsensor.ae_frm_mode,
            sizeof(struct IMGSENSOR_AE_FRM_MODE));
        break;
    case SENSOR_FEATURE_GET_MIPI_PIXEL_RATE:
        switch (*feature_data) {
        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.preview.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.capture.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.normal_video.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.high_speed_video.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_SLIM_VIDEO:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.slim_video.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_CUSTOM1:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom1.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_CUSTOM2:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom2.mipi_pixel_rate;
            break;
        case MSDK_SCENARIO_ID_CUSTOM3:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.custom3.mipi_pixel_rate;
            break;
        default:
            *(MUINT32 *)(uintptr_t)(*(feature_data + 1))
                = imgsensor_info.preview.mipi_pixel_rate;
            break;
        }
        break;

    case SENSOR_FEATURE_SET_AWB_GAIN:
        break;
    case SENSOR_FEATURE_SET_LSC_TBL:
        break;
//#ifdef OPLUS_FEATURE_CAMERA_COMMON
    case SENSOR_FEATURE_GET_MODULE_INFO:
        break;
    case SENSOR_FEATURE_GET_MODULE_SN:
        break;
    case SENSOR_FEATURE_SET_SENSOR_OTP:
        break;
    case SENSOR_FEATURE_CHECK_MODULE_ID:
        break;
    case SENSOR_FEATURE_GET_EEPROM_COMDATA:
        memcpy(feature_return_para_32, ov16a1q_doki_common_data,
                CAMERA_EEPPROM_COMDATA_LENGTH);
        *feature_para_len = CAMERA_EEPPROM_COMDATA_LENGTH;
        break;
    case SENSOR_FEATURE_GET_EEPROM_STEREODATA:
        break;
    case SENSOR_FEATURE_GET_DISTORTIONPARAMS:
        break;
//#endif /* OPLUS_FEATURE_CAMERA_COMMON */
    default:
        break;
    }

    return ERROR_NONE;
} /* feature_control() */

static struct SENSOR_FUNCTION_STRUCT sensor_func = {
    open,
    get_info,
    get_resolution,
    feature_control,
    control,
    close
};

UINT32 OV16A1Q_MIPI_RAW_DOKI_SensorInit(struct SENSOR_FUNCTION_STRUCT **pfFunc)
{
    if (pfFunc != NULL)
        *pfFunc = &sensor_func;
    return ERROR_NONE;
} /* OV16A1Q_MIPI_RAW_SensorInit */

